
//Класс команды для вызова СБИС3 плагина
&НаКлиенте
Функция НовыйАсинхроннаяСбисКоманда(ОбработчикВызова, ДопПараметры=Неопределено) Экспорт
	Перем СбисАккаунт, ВремяОжиданияОтвета, МодульВызоваКоманды;

	Результат = Новый Структура(
	"ОбработчикВызова, АргументВызова, Идентификатор, События, Аккаунт, Ответ, ВремяОжиданияОтвета, ВремяВызова, ВремяПолучения, Контракт",
	ОбработчикВызова); 
	Если Не ДопПараметры = Неопределено Тогда
		ЗаполнитьЗначенияСвойств(Результат, ДопПараметры);
	КонецЕсли;
	
	Попытка
		Результат.Идентификатор = ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.СгенерироватьИдЗапроса(ГлавноеОкно.Кэш);
	Исключение
		ВызватьСбисИсключение(ИнформацияОбОшибке(), ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя") + ".СБИСПлагин_Команда", 400);
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Результат.Аккаунт) Тогда
		Результат.Аккаунт = ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.СбисИдАккаунта(ГлавноеОкно.Кэш);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Результат.ВремяОжиданияОтвета) Тогда
		Результат.ВремяОжиданияОтвета = ПолучитьЗначениеПараметраСбис("ВремяОжиданияОтвета");
	КонецЕсли;
	
	Если Результат.События = Неопределено Тогда
		Результат.События = Новый Структура;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура РезультатОтправки_УстановитьКОтправке(РезультатОтправки, ДанныеОтправки) Экспорт
	Перем ПодготовленныеСоответствие;
	
	ИдПакета = СоставПакета_Идентификатор(ДанныеОтправки.СоставПакета);
	Если Не РезультатОтправки.Свойство("ПодготовленныеКОтправке", ПодготовленныеСоответствие) Тогда
		
		ПодготовленныеСоответствие = Новый Соответствие;
		РезультатОтправки.Вставить("ПодготовленныеКОтправке", ПодготовленныеСоответствие)
		
	КонецЕсли;
	
	ПодготовленныеСоответствие.Вставить(ИдПакета, ДанныеОтправки);
	
КонецПроцедуры
	
//Готовит пакет к отправке, формиует события-обработчики, делает вызов
//ПараметрыОтправки - СоставПакета, ДокументОтправить
&НаКлиенте
Процедура РезультатОтправки_Асинх_Отправка(РезультатОтправки, ДанныеОтправки) Экспорт
	Перем АргументОтправки;
	
	//Если у пакета нет ИД, то извлечем его из пользовательского, либо составим новый и добавим в пакет, чтобы при подготовке он был обработан
	СоставПакета = ДанныеОтправки.СоставПакета;

	Если ДанныеОтправки.Свойство("ДокументОтправить") Тогда
		АргументОтправки = ДанныеОтправки;
	Иначе
		//Подготовить пакет к отправке
		Попытка
			АргументОтправки = СоставПакета_ПодготовитьКОтправке(СоставПакета);
		Исключение
			СбисИсключение		= НовыйСбисИсключение(ИнформацияОбОшибке(), ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя") + ".РезультатОтправки_Асинх_Отправка");
			ПараметрыДобавить	= Новый Структура("ИдентификаторОтправки, СоставПакета", СоставПакета_Идентификатор(ДанныеОтправки.СоставПакета), ДанныеОтправки.СоставПакета);
			РезультатОтправки_ОбработатьОшибку(РезультатОтправки, СбисИсключение, ПараметрыДобавить);
			Возврат;
		КонецПопытки;
		//Счетчик по обработанным документам
		РезультатОтправки.ПорНомер = РезультатОтправки.ПорНомер + 1;
	КонецЕсли;
	Если АргументОтправки.СтатусПакета = "Готов" Тогда
		
		ОбработчикОтправки	= НовыйСбисОписаниеОповещения("СБИС_ЗаписатьДокументЭКС", ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция, Новый Структура("Кэш", ГлавноеОкно.Кэш));
		ПараметрыСобытий	= Новый Структура("Кэш, СоставПакета", ГлавноеОкно.Кэш, АргументОтправки.СоставПакета);
		СобытияОтправки		= ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.Отправка_ПодпискиСобытия(ПараметрыСобытий);
		ПараметрыКоманды	= Новый Структура("АргументВызова, ВремяОжиданияОтвета, События", АргументОтправки, ПолучитьЗначениеПараметраСбис("ВремяОжиданияОтвета_Отправка"), СобытияОтправки);
		Сбис3Команда		= НовыйАсинхроннаяСбисКоманда(ОбработчикОтправки, ПараметрыКоманды);

		Попытка
			АсинхроннаяСбисКоманда_Выполнить(Сбис3Команда);
		Исключение
			Сбис3Команда.Ответ	= НовыйСбисИсключение(ИнформацияОбОшибке(), ПолучитьЗначениеПараметраСбис("РезультатОтправки_Асинх_Отправка") + ".РезультатОтправки_Асинх_Отправка");
			ПараметрыДобавить	= Новый Структура("ИдентификаторОтправки, СоставПакета", Сбис3Команда.Идентификатор, ДанныеОтправки.СоставПакета);
			РезультатОтправки_ОбработатьОшибку(РезультатОтправки, Сбис3Команда.Ответ, ПараметрыДобавить)
		КонецПопытки;
		
	Иначе
		
		//Добавим команду в очередь, пока не будет проставлена пометка Готов
		РезультатОтправки_УстановитьКОтправке(РезультатОтправки, АргументОтправки);
		
	КонецЕсли;

КонецПроцедуры

//Вызываем метод плагина и подключаем обработчик на результат.
&НаКлиенте
Процедура АсинхроннаяСбисКоманда_Выполнить(АсинхроннаяСбисКоманда) Экспорт
	
	Попытка
		ВыполнитьСбисОписаниеОповещения(АсинхроннаяСбисКоманда, АсинхроннаяСбисКоманда.ОбработчикВызова);
	Исключение
		ВызватьСбисИсключение(ИнформацияОбОшибке(), ПолучитьЗначениеПараметраСбис("АсинхроннаяСбисКоманда_Выполнить"));
	КонецПопытки;
	
	АсинхроннаяСбисКоманда_ЗанятьПоток(АсинхроннаяСбисКоманда);
	
КонецПроцедуры

//Занимает поток
&НаКлиенте
Процедура АсинхроннаяСбисКоманда_ЗанятьПоток(Сбис3Команда) Экспорт
	
	ИзменитьПараметрСБИС("Потоки_КоличествоСвободных", ПолучитьЗначениеПараметраСбис("Потоки_КоличествоСвободных") - 1);
	ГлобальныйКэш.СБИС.ДанныеИнтеграции.Плагин.Потоки.Вставить(СБИС3Команда.Идентификатор, СБИС3Команда);
	Если ПолучитьЗначениеПараметраСбис("РежимОтладки") Тогда
		лОтладочныеДанные = Новый Структура("Тип, Модуль, Вызов, Время, Идентификатор, Сообщение", "CALL", Сбис3Команда.Модуль, Сбис3Команда.Метод, Сбис3Команда.ВремяВызова, Сбис3Команда.Идентификатор, СбисРаботаСJSON.ПреобразоватьЗначениеВJson(Сбис3Команда.Параметры));
		ДанныеВЛог = Новый Массив;
		ДанныеВЛог.Добавить(лОтладочныеДанные);
		СохранитьОтладочныеДанныеСБИС(Новый Структура("Log", ДанныеВЛог));
	КонецЕсли;

	//Сообщить(Кэш.СБИС.ПараметрыИнтеграции.Потоки_КоличествоСвободных);
КонецПроцедуры

&НаКлиенте
Функция СоставПакета_СтруктураКонтрагентаДляОтправки(СоставПакета) Экспорт
	Перем ДопПараметрыСтороны;
	
	kontr = Новый Структура; 
	
	//ИД контрагента
	Если	СоставПакета.Контрагент.Свойство("Идентификатор")
		И	ЗначениеЗаполнено(СоставПакета.Контрагент.Идентификатор) Тогда
		kontr.Вставить( "Идентификатор", СоставПакета.Контрагент.Идентификатор);
	Иначе
		СбисИдентификаторКонтрагента = ПрочитатьДополнительныйПараметрСтороны(СоставПакета.Контрагент, "КодОператораАбонентскогоЯщика");
		Если Не СбисИдентификаторКонтрагента = Неопределено Тогда
			//ИД явно не указан, то проверить наличие ИД оператора А/Я
			kontr.Вставить("Идентификатор", СбисИдентификаторКонтрагента);
		КонецЕсли;
	КонецЕсли;
	
	//Контакты
	Если СоставПакета.Контрагент.Свойство("Контакт")  Тогда
		Если СоставПакета.Контрагент.Контакт.Свойство("Телефон")  Тогда
			kontr.Вставить( "Телефон", СоставПакета.Контрагент.Контакт.Телефон );
		КонецЕсли;
		Если СоставПакета.Контрагент.Контакт.Свойство("EMAIL")  Тогда
			kontr.Вставить( "Email", СоставПакета.Контрагент.Контакт.EMAIL );
		КонецЕсли;
	КонецЕсли;
	
	//СвФЛ/СвЮл
	Если СоставПакета.Контрагент.Свойство("СвФЛ") Тогда
		СвФЛ = Новый Структура;
		Если СоставПакета.Контрагент.Свойство("Параметр") Тогда
			Для Каждого Параметр из СоставПакета.Контрагент.Параметр Цикл
				Если Параметр.Имя = "ЧастноеЛицо" Тогда
					СвФЛ.Вставить("ЧастноеЛицо", Параметр.Значение);
				КонецЕсли;
				Если Параметр.Имя = "СНИЛС" Тогда
					СвФЛ.Вставить("СНИЛС", Параметр.Значение);						
				КонецЕсли;     					
			КонецЦикла;
		КонецЕсли;  
		Если СоставПакета.Контрагент.СвФЛ.Свойство("ИНН") Тогда  
			СвФЛ.Вставить( "ИНН", СоставПакета.Контрагент.СвФЛ.ИНН );
		КонецЕсли;
		Если СоставПакета.Контрагент.СвФЛ.Свойство("Фамилия") Тогда
			СвФЛ.Вставить( "Фамилия", СоставПакета.Контрагент.СвФЛ.Фамилия );	
		КонецЕсли;
		Если СоставПакета.Контрагент.СвФЛ.Свойство("Имя") Тогда
			СвФЛ.Вставить( "Имя", СоставПакета.Контрагент.СвФЛ.Имя );	
		КонецЕсли;
		Если СоставПакета.Контрагент.СвФЛ.Свойство("Отчество") Тогда
			СвФЛ.Вставить( "Отчество", СоставПакета.Контрагент.СвФЛ.Отчество );	
		КонецЕсли;
		Если СоставПакета.Контрагент.СвФЛ.Свойство("КодФилиала") и ЗначениеЗаполнено(СоставПакета.Контрагент.СвФЛ.КодФилиала) Тогда
			СвФЛ.Вставить( "КодФилиала", СоставПакета.Контрагент.СвФЛ.КодФилиала );	
		КонецЕсли;

		kontr.Вставить( "СвФЛ", СвФЛ );	
	Иначе
		СвЮЛ = Новый Структура;
		СвЮЛ.Вставить( "ИНН", СоставПакета.Контрагент.СвЮЛ.ИНН ); 
		Если СоставПакета.Контрагент.СвЮЛ.Свойство("КПП") Тогда
			СвЮЛ.Вставить( "КПП", СоставПакета.Контрагент.СвЮЛ.КПП );
		КонецЕсли;
		Если СоставПакета.Контрагент.СвЮЛ.Свойство("КодСтраны") Тогда
			СвЮЛ.Вставить( "КодСтраны", СоставПакета.Контрагент.СвЮЛ.КодСтраны );	
		КонецЕсли;
		Если СоставПакета.Контрагент.СвЮЛ.Свойство("КодФилиала") и ЗначениеЗаполнено(СоставПакета.Контрагент.СвЮЛ.КодФилиала) Тогда
			СвЮЛ.Вставить( "КодФилиала", СоставПакета.Контрагент.СвЮЛ.КодФилиала );	
		КонецЕсли;
		Если СоставПакета.Контрагент.СвЮЛ.Свойство("Название") Тогда
			СвЮЛ.Вставить( "Название", СоставПакета.Контрагент.СвЮЛ.Название );	
		КонецЕсли;
		kontr.Вставить( "СвЮЛ", СвЮЛ );
	КонецЕсли;
	
	//Подразделение
	Если СоставПакета.Контрагент.Свойство("Подразделение") и СоставПакета.Контрагент.Подразделение.Свойство("Идентификатор") Тогда
		Подразделение = Новый Структура;
		Подразделение.Вставить( "Идентификатор", СоставПакета.Контрагент.Подразделение.Идентификатор); 
		kontr.Вставить( "Подразделение", Подразделение );
	КонецЕсли;	
	Возврат kontr;
	
КонецФункции

&НаКлиенте
Функция СоставПакета_ПодготовитьКОтправке(СоставПакета, ДопПараметры=Неопределено) Экспорт
	Перем СбисШифрование;
	
	Если		ДопПараметры = Неопределено
		Или	Не	ДопПараметры.Свойство("Шифрование", СбисШифрование) Тогда
		СбисШифрование = Ложь;
	КонецЕсли;
	
	document	= Новый Структура;
	//Сразу проставим статус, так как попали в функцию. В случае, если это не так, статус изменится (Например, в случае отправки вложения файл лоадером)
	Результат	= Новый Структура("СоставПакета, ДокументОтправить, СтатусПакета", СоставПакета, document, "Готов");
	
	//РезультатПодготовки = Новый Структура("СоставПакета, ДокументОтправить, Ошибки, Готов, Отказ", СоставПакета, document, Новый Массив, Истина, Отказ);
	Если СоставПакета.Свойство("Дата") И ЗначениеЗаполнено(СоставПакета.Дата) Тогда
		document.Вставить("Дата",СоставПакета.Дата);	
	КонецЕсли;
	Если СоставПакета.Свойство("Номер") И ЗначениеЗаполнено(СоставПакета.Номер) Тогда
		document.Вставить("Номер",СоставПакета.Номер);	
	КонецЕсли;
	//Для зашифрованных документов нет суммы
	Если СбисШифрование Тогда
		document.Вставить("Шифрование", Новый Структура("Зашифрован", "Да"));
	ИначеЕсли	СоставПакета.Свойство("Сумма")
			И	ЗначениеЗаполнено(СоставПакета.Сумма) Тогда
		document.Вставить("Сумма",СоставПакета.Сумма);	
	КонецЕсли;
	ИдПакета = СоставПакета_Идентификатор(СоставПакета);
	
	attachmentList = Новый Массив;
	document.Вставить("Вложение",		attachmentList );
	document.Вставить("Тип",			СоставПакета.Тип);
	Если СоставПакета.Свойство("Подтип") И ЗначениеЗаполнено(СоставПакета.Подтип) Тогда
		document.Вставить( "Подтип",СоставПакета.Подтип);
	КонецЕсли;
	document.Вставить("Идентификатор",	ИдПакета); 
	
	СоставПакета.Вставить("Идентификатор", ИдПакета);
	//Обработка вложений
	Для Каждого Вложение Из СоставПакета.Вложение Цикл
		ИдВложения = Строка(Новый УникальныйИдентификатор());
		Вложение.Вставить("Идентификатор", ИдВложения);
		
		file		= Новый Структура;
		attachment	= Новый Структура("Идентификатор,Файл", ИдВложения, file);
		attachmentList.Добавить(attachment);
		Если СбисШифрование Тогда
			Если ПолучитьЗначениеПараметраСбис("ШифроватьВыборочно") Тогда
				Если Вложение.Свойство("Шифрование") И Вложение.Шифрование = Истина Тогда
					attachment.Вставить("Шифрование", "Да" );
				Иначе
					attachment.Вставить("Шифрование", "Нет" );
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Вложение.Свойство("Зашифрован") Тогда   
			// может быть в случае пересылки зашифрованных пакетов
			attachment.Вставить("Зашифрован", Вложение.Зашифрован);
		КонецЕсли;
		СбисПараметрыВложения = Новый Структура("Файл,Вложение", file, Вложение);
		Если Вложение.Свойство("ПолноеИмяФайла") Тогда // внешний файл добавлен в пакет
			file.Вставить("Имя", Вложение.ИмяФайла);
			ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.Отправка_ОбработатьВнешнийФайл(ГлавноеОкно.Кэш, СбисПараметрыВложения, Результат);
		ИначеЕсли ТипЗнч(СбисПараметрыВложения.Вложение.XMLДокумента) = Тип("Соответствие") Тогда	
			file.Вставить("Подстановка", СбисПараметрыВложения.Вложение.XMLДокумента); 
		Иначе  // сформирован xml
			ИмяФайла = Вложение.СтруктураФайла.Файл.Имя+".xml";
			file.Вставить("Имя", ИмяФайла); 
			ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.Отправка_ОбработатьВнешнийФайл(ГлавноеОкно.Кэш, СбисПараметрыВложения, Результат);
		КонецЕсли;
		Если Результат.Отказ Тогда
			Продолжить;
		КонецЕсли;
		
		Если Вложение.Свойство("Подпись") Тогда //d.ch
			ЭЦП = Новый Массив;
			Для Каждого Запись из Вложение.Подпись Цикл
				ЗаписьЭЦП = Новый Структура;
				Если Запись.Свойство("Направление") Тогда
					ЗаписьЭЦП.Вставить("Направление",Запись.Направление);
				КонецЕсли;
				ФайлЭЦП = Новый Структура;
				ФайлЭЦП.Вставить( "Имя", Запись.Файл.Имя ); 
				ФайлЭЦП.Вставить( "ДвоичныеДанные", ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.сбисФайлСКлиентаВBASE64(Запись.Файл.ПолноеИмяФайла)); 
				ЗаписьЭЦП.Вставить("Файл",ФайлЭЦП);
				ЭЦП.Добавить(ЗаписьЭЦП);
			КонецЦикла;
			attachment.Вставить( "Подпись", ЭЦП );
		КонецЕсли;
		Если СбисШифрование Тогда
			Если Вложение.Свойство("Тип") и ЗначениеЗаполнено(Вложение.Тип) и Вложение.Свойство("ПодТип") и Вложение.Свойство("ВерсияФормата") и ЗначениеЗаполнено(Вложение.ВерсияФормата) Тогда
				attachment.Вставить( "Тип",  Вложение.Тип);
				attachment.Вставить( "Подтип",  Вложение.ПодТип);
				attachment.Вставить( "ВерсияФормата",  Вложение.ВерсияФормата);
				Если Вложение.Свойство("ПодВерсияФормата") и ЗначениеЗаполнено(Вложение.ПодВерсияФормата) Тогда
					attachment.Вставить( "ПодверсияФормата",  Вложение.ПодВерсияФормата);
				КонецЕсли;
			КонецЕсли;
			Если Вложение.Свойство("Название") и ЗначениеЗаполнено(Вложение.Название) Тогда
				// для зашифрованных документов убираем сумму из названия
				ПозСуммы = Найти(Вложение.Название, "на сумму");
				Если ПозСуммы>0 Тогда
					Вложение.Название = Лев(Вложение.Название, ПозСуммы-1);
				КонецЕсли;
				attachment.Вставить("Название",  Вложение.Название);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если СоставПакета.Свойство("ПользовательскийИдентификатор") Тогда
		redaction = Новый Структура;
		redaction.Вставить("ИдентификаторИС", СоставПакета.ПользовательскийИдентификатор);
		document.Вставить( "Редакция", redaction);
	КонецЕсли;
	Если СоставПакета.Свойство("Примечание") и ЗначениеЗаполнено(СоставПакета.Примечание) Тогда
		document.Вставить( "Примечание", СоставПакета.Примечание);
	КонецЕсли;
	
	org = Новый Структура; 
	Если СоставПакета.НашаОрганизация.Свойство("СвФЛ") Тогда
		СвФЛ = Новый Структура;
		СвФЛ.Вставить( "ИНН", СоставПакета.НашаОрганизация.СвФЛ.ИНН); 
		Если СоставПакета.НашаОрганизация.СвФЛ.Свойство("КодФилиала") и ЗначениеЗаполнено(СоставПакета.НашаОрганизация.СвФЛ.КодФилиала) Тогда
			СвФЛ.Вставить( "КодФилиала", СоставПакета.НашаОрганизация.СвФЛ.КодФилиала );	
		КонецЕсли;
		org.Вставить( "СвФЛ", СвФЛ );	
	Иначе
		СвЮЛ = Новый Структура;
		СвЮЛ.Вставить( "ИНН", СоставПакета.НашаОрганизация.СвЮЛ.ИНН ); 
		СвЮЛ.Вставить( "КПП", СоставПакета.НашаОрганизация.СвЮЛ.КПП );
		Если СоставПакета.НашаОрганизация.СвЮЛ.Свойство("КодФилиала") и ЗначениеЗаполнено(СоставПакета.НашаОрганизация.СвЮЛ.КодФилиала) Тогда
			СвЮЛ.Вставить( "КодФилиала", СоставПакета.НашаОрганизация.СвЮЛ.КодФилиала );	
		КонецЕсли;
		Если СоставПакета.НашаОрганизация.СвЮЛ.Свойство("КодСтраны") Тогда
			СвЮЛ.Вставить( "КодСтраны", СоставПакета.НашаОрганизация.СвЮЛ.КодСтраны );	
		КонецЕсли;
		org.Вставить( "СвЮЛ", СвЮЛ );
	КонецЕсли;
	document.Вставить( "НашаОрганизация", org );
	
	Если СоставПакета.Свойство("Контрагент") Тогда
		document.Вставить("Контрагент", СоставПакета_СтруктураКонтрагентаДляОтправки(СоставПакета));
	КонецЕсли;
	
	Если СоставПакета.Свойство("Ответственный") и СоставПакета.Ответственный.Количество()>0 Тогда
		otv = Новый Структура;
		Для Каждого Элемент Из СоставПакета.Ответственный Цикл
			otv.Вставить( Элемент.Ключ, Элемент.Значение );	
		КонецЦикла;
		document.Вставить( "Ответственный", otv ); 	
	КонецЕсли;
	Если СоставПакета.Свойство("Подразделение") и СоставПакета.Подразделение.Количество()>0 Тогда
		podrazdel = Новый Структура;
		Для Каждого Элемент Из СоставПакета.Подразделение Цикл
			podrazdel.Вставить( Элемент.Ключ, Элемент.Значение );	
		КонецЦикла;
		document.Вставить( "Подразделение", podrazdel ); 	
	КонецЕсли;
	Если СоставПакета.Свойство("Регламент") и СоставПакета.Регламент.Количество()>0 Тогда
		regl = Новый Структура;
		Для Каждого Элемент Из СоставПакета.Регламент Цикл
			regl.Вставить( Элемент.Ключ, Элемент.Значение );	
		КонецЦикла;
		document.Вставить( "Регламент", regl ); 	
	КонецЕсли;
	Если СоставПакета.Свойство("ДокументОснование") и СоставПакета.ДокументОснование.Количество()>0 Тогда
		osnovania = Новый Массив;
		Для Каждого ДокОсн Из СоставПакета.ДокументОснование Цикл 
			osn = Новый Структура;
			Если ДокОсн.Свойство("ВидСвязи") Тогда
				osn.Вставить( "ВидСвязи", ДокОсн.ВидСвязи );	
			КонецЕсли;
			doc = Новый Структура;
			Для Каждого Элемент Из ДокОсн Цикл
				Если Элемент.Ключ<>"ВидСвязи" Тогда
					doc.Вставить( Элемент.Ключ, Элемент.Значение );	
				КонецЕсли;
			КонецЦикла;
			osn.Вставить( "Документ", doc );
			osnovania.Добавить(osn);
		КонецЦикла;
		document.Вставить( "ДокументОснование", osnovania ); 				
	КонецЕсли;
	Если	СоставПакета.Свойство("НеЗапускатьВДокументооборот")
		И	СоставПакета.НеЗапускатьВДокументооборот = Истина Тогда
		document.Вставить("НеЗапускатьВДокументооборот", "Да");
	КонецЕсли;
	Если	СоставПакета.Свойство("ДопПоля") Тогда // alo ДопПоля
		DopPolya = Новый Массив;
		Для Каждого Поле Из СоставПакета.ДопПоля Цикл 
			DopPolya.Добавить(Поле.Ключ);
		КонецЦикла;
		document.Вставить( "ДопПоля", DopPolya );
	КонецЕсли;
	Если	СоставПакета.Свойство("Провести")	// alo Провести
		И	( СоставПакета.Провести = Истина или СоставПакета.Провести = "Да") Тогда
		document.Вставить("Провести", "Да");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура РезультатОтправки_ПоставитьВОчередьНаПовторнуюОтправку(РезультатОтправки, ИдентификаторОтправки) Экспорт
	
	Если Не РезультатОтправки.Свойство("ПакетыДляПереотправки") Тогда
		
		РезультатОтправки.Вставить("ПакетыДляПереотправки",		Новый Массив);
		РезультатОтправки.Вставить("КоличествоПереотправок",	0);
		
	КонецЕсли;
	
	РезультатОтправки.ПакетыДляПереотправки.Добавить(РезультатОтправки.СформированныеПакеты.Получить(ИдентификаторОтправки));
	РезультатОтправки.КоличествоПереотправок = РезультатОтправки.КоличествоПереотправок + 1;
	
КонецПроцедуры

//Отправляет пакет в свободный поток или добавляет в очередь
&НаКлиенте
Процедура РезультатОтправки_ДокументВСвободныйПоток(РезультатОтправки, ДанныеОтправки, ДопПараметры) Экспорт
	
	МаксСвободныхПотоковОтправки = ПолучитьЗначениеПараметраСбис("Потоки_МаксимальноеКоличество");
	Если		ПолучитьЗначениеПараметраСбис("Потоки_КоличествоСвободных") Тогда
		//Есть свободный поток, сразу отправляем его в путь
	ИначеЕсли	ДопПараметры.ДобавлятьВОчередь//Есть место в кэше для подготовленных, добавим в очередь
			И	РезультатОтправки.ПодготовленныеКОтправке.Количество() < МаксСвободныхПотоковОтправки Тогда
		
		РезультатОтправки_УстановитьКОтправке(РезультатОтправки, ДанныеОтправки);

		Возврат;
		
	Иначе//Очередь заполнена, ждём, пока освободятся потоки. Пока идёт ожидание, записываем статусы по полученным ответам
		Пока Не ПолучитьЗначениеПараметраСбис("Потоки_КоличествоСвободных") Цикл 
			ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция.Отправка_ОжиданиеПотока(ГлавноеОкно.Кэш)
		КонецЦикла;	
	КонецЕсли;
	
	Попытка 
		
		РезультатОтправки_Асинх_Отправка(РезультатОтправки, ДанныеОтправки);
		
	Исключение
		ИдОтправки		= СоставПакета_Идентификатор(ДанныеОтправки.СоставПакета);
		ПараметрыОшибки	= Новый Структура("Фатальная, ИдентификаторОтправки, СоставПакета", Истина, ИдОтправки, ДанныеОтправки.СоставПакета);
		ОшибкаОтправки	= НовыйСбисИсключение(ИнформацияОбОшибке(), "МодульОбъектаКлиент.РезультатОтправки_ДокументВСвободныйПоток");
		РезультатОтправки_ОбработатьОшибку(РезультатОтправки, ОшибкаОтправки, ПараметрыОшибки);
	КонецПопытки;
	
КонецПроцедуры

//Отправляет подготовленные пакеты пока есть свободные потоки
&НаКлиенте
Процедура РезультатОтправки_ОтправитьНакопленные(РезультатОтправки, ОжидатьСвободныеПотоки=Истина) Экспорт
	Перем ПодготовленныеКОтправкеПакеты, ПереотправляемыеПакеты;
	
	Если Не	РезультатОтправки.Свойство("ПодготовленныеКОтправке",	ПодготовленныеКОтправкеПакеты) Тогда
		ПодготовленныеКОтправкеПакеты = Новый Соответствие;
		РезультатОтправки.Вставить("ПодготовленныеКОтправке",	ПодготовленныеКОтправкеПакеты);
	КонецЕсли;
	Если Не	РезультатОтправки.Свойство("ПакетыДляПереотправки",		ПереотправляемыеПакеты) Тогда
		ПереотправляемыеПакеты = Новый Соответствие;
		РезультатОтправки.Вставить("ПакетыДляПереотправки",		ПереотправляемыеПакеты);
	КонецЕсли;
	
	ПакетыОтправлены = Новый Массив;
	Для Каждого КлючИЗначениеПодготовлен Из ПодготовленныеКОтправкеПакеты Цикл
		Если 		ОжидатьСвободныеПотоки
			И	Не	ПолучитьЗначениеПараметраСбис("Потоки_КоличествоСвободных") Тогда
			Прервать;
		ИначеЕсли Не	(	КлючИЗначениеПодготовлен.Значение.СтатусПакета = "Готов"
						Или	КлючИЗначениеПодготовлен.Значение.СтатусПакета = "Подготовка") Тогда
			Продолжить;
		КонецЕсли;
		РезультатОтправки_ДокументВСвободныйПоток(РезультатОтправки, КлючИЗначениеПодготовлен.Значение, Новый Структура("ДобавлятьВОчередь", Ложь));
		ПакетыОтправлены.Добавить(КлючИЗначениеПодготовлен.Ключ);
	КонецЦикла;
	Для Каждого ПакетОтправлен Из ПакетыОтправлены Цикл
		//Отправка должна проставить статус отправлен, иначе могло выйти так, что в процессе необходимо выполнить дополнительные действия и пакет пока не был отправлен
		Если ПодготовленныеКОтправкеПакеты.Получить(ПакетОтправлен).СтатусПакета = "Отправлен" Тогда
			ПодготовленныеКОтправкеПакеты.Удалить(ПакетОтправлен);
		КонецЕсли;
	КонецЦикла;

	ПакетыОтправлены = Новый Массив;
	Для Каждого КлючИЗначениеПодготовлен Из ПереотправляемыеПакеты Цикл
		Если 		ОжидатьСвободныеПотоки
			И	Не	ПолучитьЗначениеПараметраСбис("Потоки_КоличествоСвободных") Тогда
			Прервать;
		КонецЕсли;
		РезультатОтправки_ДокументВСвободныйПоток(РезультатОтправки, КлючИЗначениеПодготовлен.Значение, Новый Структура("ДобавлятьВОчередь", Ложь));
		ПакетыОтправлены.Добавить(КлючИЗначениеПодготовлен.Ключ);
	КонецЦикла;

	Для Каждого ПакетОтправлен Из ПакетыОтправлены Цикл
		ПереотправляемыеПакеты.Удалить(ПакетОтправлен);
	КонецЦикла;
	
КонецПроцедуры

