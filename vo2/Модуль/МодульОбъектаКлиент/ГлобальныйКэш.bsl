
&НаКлиенте
Функция	ГлобальныйКэш_ЧтениеОтветовИВызовСобытий(Сбис3КомандыОжидаются=Неопределено) Экспорт
	
	Результат				= Новый Соответствие;
	МодульРаботыСОтветами	= ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция; 
	
	Попытка
		СбисСобытия = МодульРаботыСОтветами.СБИС_ПрочитатьПулОтветов(ГлобальныйКэш.СБИС);
		ВремяПолученияСобытий = ТекущаяДата();
	Исключение
		ВызватьСбисИсключение(ИнформацияОбОшибке(), "МодульОбъектаКлиент.ГлобальныйКэш_ЧтениеОтветовИВызовСобытий");
	КонецПопытки;
	
	Для Каждого Сбис3СобытиеОтвет Из СбисСобытия Цикл
		ОтветОбработан = Ложь;
		
		АсинхронноеСбисСобытие = МодульРаботыСОтветами.СБИС_ОбработатьОтвет(Сбис3СобытиеОтвет);
		АсинхронноеСбисСобытие_Установить(АсинхронноеСбисСобытие, "Получено", ВремяПолученияСобытий);
		
		Если 		АсинхронноеСбисСобытие.Тип = "Event" Тогда
			ОтветОбработан = АсинхронноеСбисСобытие_ВызватьСобытиеПоПодписке(АсинхронноеСбисСобытие);
		ИначеЕсли   АсинхронноеСбисСобытие.Тип = "CriticalError" Тогда
			ОтветОбработан = АсинхронноеСбисСобытие_ВызватьСобытиеПоПодписке(АсинхронноеСбисСобытие);
			Если Не Сбис3КомандыОжидаются = Неопределено Тогда 
				//При крите дать ответ на все ожидаемые команды
				Для Каждого Сбис3КомандаОжидается Из Сбис3КомандыОжидаются Цикл
					НовоеАсинхронноеСобытие			= НовыйАсинхронноеСбисСобытие(Сбис3КомандаОжидается.Идентификатор, АсинхронноеСбисСобытие);
					КомандаОбрабатываемогоОтвета	= Неопределено;
					
					АсинхронноеСбисСобытие_ОсвободитьПоток(НовоеАсинхронноеСобытие, КомандаОбрабатываемогоОтвета, ОтветОбработан);
					
					Если Не КомандаОбрабатываемогоОтвета = Неопределено Тогда
						Результат.Вставить(Сбис3КомандаОжидается.Ключ, КомандаОбрабатываемогоОтвета); 
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли 	АсинхронноеСбисСобытие.Тип = "Async" Тогда
			//Если это асинхронное событие, то проставим в команду что есть ответ, но поток не снимается а продолжается его ожидание
			АсинхронныйПоток = АсинхронноеСбисСобытие_ПолучитьПоток(АсинхронноеСбисСобытие);
			Если Не АсинхронныйПоток = Неопределено Тогда
				АсинхронныйПоток.Ответ = АсинхронноеСбисСобытие.Данные;
			КонецЕсли;
			Если ПолучитьЗначениеПараметраСбис("РежимОтладки") Тогда
				лОтладочныеДанные = Новый Структура("Тип, Модуль, Вызов, Время, Идентификатор, Сообщение", АсинхронноеСбисСобытие.Тип);
				лОтладочныеДанные.Модуль		= ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя");
				лОтладочныеДанные.Сообщение		= АсинхронноеСбисСобытие.Данные;
				лОтладочныеДанные.Идентификатор	= АсинхронноеСбисСобытие.Идентификатор;
				лОтладочныеДанные.Время			= АсинхронноеСбисСобытие.Получено;
				Если АсинхронныйПоток = Неопределено Тогда
					лОтладочныеДанные.Вызов		= "Unknown";
				Иначе
					лОтладочныеДанные.Вызов		=  АсинхроннаяСбисКоманда_ИмяВызова(АсинхронныйПоток);
				КонецЕсли;
				ДанныеВЛог = Новый Массив;
				ДанныеВЛог.Добавить(лОтладочныеДанные);
				СохранитьОтладочныеДанныеСБИС(Новый Структура("Log", ДанныеВЛог));
			КонецЕсли;
			
			//Асинхронное событие, поместить промежуточный ответ на всякий
			Продолжить;
		КонецЕсли;
		
		//После чтения ответа, посмотрим что с ним сделать:
		//1. Есть соответствующий запрос, отправленный ранее. Тогда надо освободить поток и проверить наличие подписки на тип ответа и вызвать обработчик.
		//2. Мы ожидаем этот ответ синхронно, тогда добавим его в результат чтения.
		//3. Если не 1 и не 2, то добавим полученный ответ в список "ненужных", при необходимости обработать, или выгрузить в лог (включить режим отладки).
				
		КомандаОбрабатаемогоОтвета = Неопределено;
		АсинхронноеСбисСобытие_ОсвободитьПоток(АсинхронноеСбисСобытие, КомандаОбрабатаемогоОтвета, ОтветОбработан);
		
		//Если команда ожидается как ответ, подготовим результат
		КомандаНаВозврат = Неопределено;
		Если	Не Сбис3КомандыОжидаются		= Неопределено
			И	Не КомандаОбрабатаемогоОтвета	= Неопределено Тогда
			КомандаНаВозврат = Сбис3КомандыОжидаются.Получить(КомандаОбрабатаемогоОтвета.Идентификатор);
		КонецЕсли;
		
		Если КомандаНаВозврат = Неопределено Тогда
			
			Если Не ОтветОбработан Тогда
				АсинхронноеСбисСобытие_ДобавитьНеобработанныйОтвет(АсинхронноеСбисСобытие);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
	
		Результат.Вставить(АсинхронноеСбисСобытие.Идентификатор, КомандаНаВозврат);
		Сбис3КомандыОжидаются.Удалить(АсинхронноеСбисСобытие.Идентификатор);
		
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ГлобальныйКэш_ОбработатьПросроченныеВызовы(СбисТочкаПроверки=Неопределено, Завершение=Ложь) Экспорт
	//Проверим отправленные запросы на предмет их актуальности.
	Если СбисТочкаПроверки = Неопределено Тогда
		СбисТочкаПроверки = ТекущаяДата();
	КонецЕсли;
	ЗапросыПросрочены = Новый Массив;
	Для Каждого КлючИЗначениеЗапросов Из ГлобальныйКэш.СБИС.ДанныеИнтеграции.Потоки Цикл
		Если		СбисТочкаПроверки - КлючИЗначениеЗапросов.Значение.ВремяВызова <= КлючИЗначениеЗапросов.Значение.ВремяОжиданияОтвета
			И Не	Завершение Тогда//Если завершение работы, то все вызовы "убиваются"
			Продолжить;
		КонецЕсли;
					
		ЗапросыПросрочены.Добавить(КлючИЗначениеЗапросов.Ключ);
	КонецЦикла;            

	Для Каждого ИдЗапросПросрочен Из ЗапросыПросрочены Цикл
		//Генерируем сообщение о просроченном запросе, чистим вызов так как уже не ждём ответа, если есть подписка на событие не получен ответ, вызываем.		
		АсинхронноеСбисСобытие		= НовыйАсинхронноеСбисСобытие(ИдЗапросПросрочен, , "Error");
		Сбис3КомандаПросрочена		= АсинхронноеСбисСобытие_ПолучитьПоток(АсинхронноеСбисСобытие);
		
		ИмяКомандыНеполученОтвет	= Сбис3КомандаПросрочена.ОбработчикВызова.ИмяПроцедуры;
		
		Если ИмяКомандыНеполученОтвет = "СбисОтправитьКоманду_Асинхронно" Тогда
			
			ИмяКомандыНеполученОтвет = Сбис3КомандаПросрочена.АргументВызова.Метод;
			
		КонецЕсли;
		
		ОтветПросрочено = НовыйСбисИсключение(775, ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя") + "." + ИмяКомандыНеполученОтвет,,, ИмяКомандыНеполученОтвет + "() не вернул ответ за разумное время");
		
		АсинхронноеСбисСобытие_Установить(АсинхронноеСбисСобытие, "Данные",	ОтветПросрочено);
		АсинхронноеСбисСобытие_ОсвободитьПоток(АсинхронноеСбисСобытие, Сбис3КомандаПросрочена, Истина);
		
		Если Не АсинхроннаяСбисКоманда_ВызватьСобытие(Сбис3КомандаПросрочена, АсинхронноеСбисСобытие) Тогда
			АсинхронноеСбисСобытие_ДобавитьНеобработанныйОтвет(АсинхронноеСбисСобытие);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

//Обрабатываем необработанные в срок ответы, чистим их по времени существования ответа
&НаКлиенте
Процедура ГлобальныйКэш_ОчиститьНевостребованныеОтветы(Аргумент = Неопределено, ДопПараметры = Неопределено) Экспорт
	
	Если Не ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Количество() Тогда
		Возврат;
	КонецЕсли;

	ТочкаПроверки	= ТекущаяДата();
	ДанныеВЛог		= Новый Массив;
	ВремяОжидания	= ПолучитьЗначениеПараметраСбис("ВремяОжиданияОтвета");

	КлючиОтветовНеВостребованы = Новый Массив;
	Для Каждого КлючИЗначениеОтвета Из ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы Цикл
		ИндексКоманд = 0;
		Пока ИндексКоманд < КлючИЗначениеОтвета.Значение.Количество() Цикл
			АсинхронноеСбисСобытие = КлючИЗначениеОтвета.Значение[ИндексКоманд];
			Если ТочкаПроверки - АсинхронноеСбисСобытие.Получено > ВремяОжидания Тогда
				Если ПолучитьЗначениеПараметраСбис("РежимОтладки") Тогда
					//Дампаем в лог необработанные события если надо
					лОтладочныеДанные = Новый Структура("Тип, Модуль, Вызов, Время, Сообщение, Идентификатор");
					лОтладочныеДанные.Модуль		= ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя");
					лОтладочныеДанные.Тип			= АсинхронноеСбисСобытие.Тип;
					лОтладочныеДанные.Идентификатор	= АсинхронноеСбисСобытие.Идентификатор;
					лОтладочныеДанные.Вызов			= "Unknown";
					лОтладочныеДанные.Время			= АсинхронноеСбисСобытие.Получено;
					лОтладочныеДанные.Сообщение		= АсинхронноеСбисСобытие.Данные;

					ДанныеВЛог.Добавить(лОтладочныеДанные);
				КонецЕсли;
				КлючИЗначениеОтвета.Значение.Удалить(ИндексКоманд);
			Иначе
				ИндексКоманд = ИндексКоманд + 1;
			КонецЕсли;
		КонецЦикла;
		Если Не КлючИЗначениеОтвета.Значение.Количество() Тогда
			КлючиОтветовНеВостребованы.Добавить(КлючИЗначениеОтвета.Ключ);
		КонецЕсли;
	КонецЦикла;
	Для Каждого КлючУдалить Из КлючиОтветовНеВостребованы Цикл
		ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Удалить(КлючУдалить);
	КонецЦикла;
	Если ДанныеВЛог.Количество() Тогда
		СохранитьОтладочныеДанныеСБИС(Новый Структура("Log", ДанныеВЛог));
	КонецЕсли;
	
	//Каждую минуту в режиме простоя повторно проверяем оставшиеся невостребованными сообщения, пока не будут почищены все.
	Если ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Количество() Тогда
		ПараметрыОтложенногоВызова = Новый Структура("Модуль, Периодичность, ВызватьСразу, ИмяПроцедуры, Аргумент, ИдентификаторДействия", МодульОбъектаКлиент(), 60, Ложь);
		ПараметрыОтложенногоВызова.ИмяПроцедуры				= "ГлобальныйКэш_ОчиститьНевостребованныеОтветы";
		ПараметрыОтложенногоВызова.ИдентификаторДействия	= Новый УникальныйИдентификатор;
		ПодключитьОтложенноеДействие(НовыйОтложенноеДействие(ПараметрыОтложенногоВызова));
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ГлобальныйКэш_КоличествоАктивныхПотоков() Экспорт
	Возврат ГлобальныйКэш.СБИС.ДанныеИнтеграции.Потоки.Количество();
КонецФункции

&НаКлиенте
Процедура УстановитьПараметрыГлобальногоМодуля(ПараметрыУстановки=Неопределено, Кэш) Экспорт
	
	ГлобальныйКэшНовый	= Новый Структура("КэшНастроек, СБИС, Парам, ТекущийСеанс, ПараметрыСистемы, ТихийРежим, СовместимостьМетодов");
	Если ГлобальныйКэш = Неопределено Тогда
		ГлобальныйКэш	= ГлобальныйКэшНовый;
	Иначе
		Для Каждого КлючИЗначение Из ГлобальныйКэшНовый Цикл
			Если ГлобальныйКэш.Свойство(КлючИЗначение.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			ГлобальныйКэш.Вставить(КлючИЗначение.Ключ);
		КонецЦикла;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(ГлобальныйКэш, Кэш);
	СбисРаботаСJSON	= Кэш.РаботаСJSON;
	ГлавноеОкно		= Кэш.ГлавноеОкно;
	
КонецПроцедуры

&НаКлиенте
Функция ГлобальныйКэш_Получить(ИмяПараметраМодуля) Экспорт
	Перем ЗначениеПараметраМодуля;
	Если 	ГлобальныйКэш = Неопределено Тогда
		ГлобальныйКэш = Новый Структура;
	КонецЕсли;

	Если ИмяПараметраМодуля = "ПараметрыСистемы" Тогда
		Если	ГлобальныйКэш.Свойство(ИмяПараметраМодуля, ЗначениеПараметраМодуля) Тогда
			Возврат ЗначениеПараметраМодуля;
		КонецЕсли;
		ЗначениеПараметраМодуля = ПолучитьПараметрыСистемы();
		ОбновитьПараметрГлобальногоМодуля(ИмяПараметраМодуля, ЗначениеПараметраМодуля);
		Возврат ЗначениеПараметраМодуля;
	ИначеЕсли ИмяПараметраМодуля = "ПараметрыПользователя" Тогда
		Если	ГлобальныйКэш.Свойство("Парам", ЗначениеПараметраМодуля) Тогда
			Возврат ЗначениеПараметраМодуля;
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

&НаКлиенте
Процедура ОбновитьПараметрГлобальногоМодуля(ИмяПараметраМодуля, ЗначениеПараметраМодуля) Экспорт
	
	Если		ИмяПараметраМодуля = "КэшНастроек"		Тогда
		
		ГлавноеОкно.Кэш.Вставить("КэшНастроек", ЗначениеПараметраМодуля);
		ГлобальныйКэш.КэшНастроек = ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "РаботаСJSON"		Тогда
		
		ГлавноеОкно.Кэш[ИмяПараметраМодуля] = ЗначениеПараметраМодуля;
		СбисРаботаСJSON						= ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "Парам"			Тогда
		
		ГлобальныйКэш[ИмяПараметраМодуля]	= ЗначениеПараметраМодуля;
		ГлавноеОкно.Кэш[ИмяПараметраМодуля] = ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "ФормаНастроек"	Тогда
		
		ГлобальныйКэш.ТекущийСеанс.Модули.Настройки = ЗначениеПараметраМодуля;
		ГлавноеОкно.Кэш[ИмяПараметраМодуля]			= ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "ГлавноеОкно"		Тогда
		
		ГлавноеОкно = ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "ФункцииДокументов"Тогда
		
		ГлобальныйКэш.ТекущийСеанс.Модули.ФункцииДокументов		= ЗначениеПараметраМодуля;
		ГлавноеОкно.Кэш.ТекущийСеанс.Модули.ФункцииДокументов	= ЗначениеПараметраМодуля;
		
	ИначеЕсли	ИмяПараметраМодуля = "ПараметрыСистемы"	Тогда
		
		ГлобальныйКэш.Вставить("ПараметрыСистемы", ЗначениеПараметраМодуля);
		Если	Не ГлавноеОкно = Неопределено
			И	Не ГлавноеОкно.Кэш = Неопределено Тогда
			
			ГлавноеОкно.Кэш.Вставить("ПараметрыСистемы", ЗначениеПараметраМодуля);
			
		КонецЕсли;
		
	ИначеЕсли	ИмяПараметраМодуля = "ДанныеИнтеграции"	Тогда
		
		ГлобальныйКэш.СБИС.ДанныеИнтеграции		= ЗначениеПараметраМодуля;	
		ГлавноеОкно.Кэш.СБИС.ДанныеИнтеграции	= ЗначениеПараметраМодуля;
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьТекущийЛокальныйКэш() Экспорт
	
	Возврат ГлавноеОкно.Кэш;
	
КонецФункции

