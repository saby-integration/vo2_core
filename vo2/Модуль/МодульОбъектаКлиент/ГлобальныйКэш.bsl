
// Функция - создаёт новый глобальный кэш
// 
// Возвращаемое значение:
//  Структура - 
//
&НаКлиенте
#Область include_core2_vo2_Модуль_Функции_НовыйГлобальныйКэш
#КонецОбласти

&НаКлиенте
#Область include_core2_vo2_Модуль_Функции_ОбновитьПараметрГлобальногоМодуля
#КонецОбласти

&НаКлиенте
Функция	ГлобальныйКэш_ЧтениеОтветовИВызовСобытий(Сбис3КомандыОжидаются=Неопределено) Экспорт
	
	Результат				= Новый Соответствие;
	МодульРаботыСОтветами	= ГлобальныйКэш.ТекущийСеанс.Модули.Интеграция; 
	
	Попытка
		СбисСобытия = МодульРаботыСОтветами.СБИС_ПрочитатьПулОтветов(ГлобальныйКэш.СБИС);
		ВремяПолученияСобытий = ТекущаяДата();
	Исключение
		ВызватьСбисИсключение(ИнформацияОбОшибке(), "МодульОбъектаКлиент.ГлобальныйКэш_ЧтениеОтветовИВызовСобытий");
	КонецПопытки;
	
	Для Каждого Сбис3СобытиеОтвет Из СбисСобытия Цикл
		ОтветОбработан = Ложь;
		
		АсинхронноеСбисСобытие = МодульРаботыСОтветами.СБИС_ОбработатьОтвет(Сбис3СобытиеОтвет);
		АсинхронноеСбисСобытие_Установить(АсинхронноеСбисСобытие, "Получено", ВремяПолученияСобытий);
		
		Если 		АсинхронноеСбисСобытие.Тип = "Event" Тогда
			ОтветОбработан = АсинхронноеСбисСобытие_ВызватьСобытиеПоПодписке(АсинхронноеСбисСобытие);
		ИначеЕсли   АсинхронноеСбисСобытие.Тип = "CriticalError" Тогда
			ОтветОбработан = АсинхронноеСбисСобытие_ВызватьСобытиеПоПодписке(АсинхронноеСбисСобытие);
			Если Не Сбис3КомандыОжидаются = Неопределено Тогда 
				//При крите дать ответ на все ожидаемые команды
				Для Каждого Сбис3КомандаОжидается Из Сбис3КомандыОжидаются Цикл
					НовоеАсинхронноеСобытие			= НовыйАсинхронноеСбисСобытие(Сбис3КомандаОжидается.Идентификатор, АсинхронноеСбисСобытие);
					КомандаОбрабатываемогоОтвета	= Неопределено;
					
					АсинхронноеСбисСобытие_ОсвободитьПоток(НовоеАсинхронноеСобытие, КомандаОбрабатываемогоОтвета, ОтветОбработан);
					
					Если Не КомандаОбрабатываемогоОтвета = Неопределено Тогда
						Результат.Вставить(Сбис3КомандаОжидается.Ключ, КомандаОбрабатываемогоОтвета); 
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли 	АсинхронноеСбисСобытие.Тип = "Async" Тогда
			//Если это асинхронное событие, то проставим в команду что есть ответ, но поток не снимается а продолжается его ожидание
			АсинхронныйПоток = АсинхронноеСбисСобытие_ПолучитьПоток(АсинхронноеСбисСобытие);
			Если Не АсинхронныйПоток = Неопределено Тогда
				АсинхронныйПоток.Ответ = АсинхронноеСбисСобытие.Данные;
			КонецЕсли;
			Если ПолучитьЗначениеПараметраСбис("РежимОтладки") Тогда
				лОтладочныеДанные = Новый Структура("Тип, Модуль, Вызов, Время, Идентификатор, Сообщение", АсинхронноеСбисСобытие.Тип);
				лОтладочныеДанные.Модуль		= ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя");
				лОтладочныеДанные.Сообщение		= АсинхронноеСбисСобытие.Данные;
				лОтладочныеДанные.Идентификатор	= АсинхронноеСбисСобытие.Идентификатор;
				лОтладочныеДанные.Время			= АсинхронноеСбисСобытие.Получено;
				Если АсинхронныйПоток = Неопределено Тогда
					лОтладочныеДанные.Вызов		= "Unknown";
				Иначе
					лОтладочныеДанные.Вызов		=  АсинхроннаяСбисКоманда_ИмяВызова(АсинхронныйПоток);
				КонецЕсли;
				ДанныеВЛог = Новый Массив;
				ДанныеВЛог.Добавить(лОтладочныеДанные);
				СохранитьОтладочныеДанныеСБИС(Новый Структура("Log", ДанныеВЛог));
			КонецЕсли;
			
			//Асинхронное событие, поместить промежуточный ответ на всякий
			Продолжить;
		КонецЕсли;
		
		//После чтения ответа, посмотрим что с ним сделать:
		//1. Есть соответствующий запрос, отправленный ранее. Тогда надо освободить поток и проверить наличие подписки на тип ответа и вызвать обработчик.
		//2. Мы ожидаем этот ответ синхронно, тогда добавим его в результат чтения.
		//3. Если не 1 и не 2, то добавим полученный ответ в список "ненужных", при необходимости обработать, или выгрузить в лог (включить режим отладки).
				
		КомандаОбрабатаемогоОтвета = Неопределено;
		АсинхронноеСбисСобытие_ОсвободитьПоток(АсинхронноеСбисСобытие, КомандаОбрабатаемогоОтвета, ОтветОбработан);
		
		//Если команда ожидается как ответ, подготовим результат
		КомандаНаВозврат = Неопределено;
		Если	Не Сбис3КомандыОжидаются		= Неопределено
			И	Не КомандаОбрабатаемогоОтвета	= Неопределено Тогда
			КомандаНаВозврат = Сбис3КомандыОжидаются.Получить(КомандаОбрабатаемогоОтвета.Идентификатор);
		КонецЕсли;
		
		Если КомандаНаВозврат = Неопределено Тогда
			
			Если Не ОтветОбработан Тогда
				АсинхронноеСбисСобытие_ДобавитьНеобработанныйОтвет(АсинхронноеСбисСобытие);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
	
		Результат.Вставить(АсинхронноеСбисСобытие.Идентификатор, КомандаНаВозврат);
		Сбис3КомандыОжидаются.Удалить(АсинхронноеСбисСобытие.Идентификатор);
		
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ГлобальныйКэш_ОбработатьПросроченныеВызовы(СбисТочкаПроверки=Неопределено, Завершение=Ложь) Экспорт
	//Проверим отправленные запросы на предмет их актуальности.
	Если СбисТочкаПроверки = Неопределено Тогда
		СбисТочкаПроверки = ТекущаяДата();
	КонецЕсли;
	ЗапросыПросрочены = Новый Массив;
	Для Каждого КлючИЗначениеЗапросов Из ГлобальныйКэш.СБИС.ДанныеИнтеграции.Потоки Цикл
		Если		СбисТочкаПроверки - КлючИЗначениеЗапросов.Значение.ВремяВызова <= КлючИЗначениеЗапросов.Значение.ВремяОжиданияОтвета
			И Не	Завершение Тогда//Если завершение работы, то все вызовы "убиваются"
			Продолжить;
		КонецЕсли;
					
		ЗапросыПросрочены.Добавить(КлючИЗначениеЗапросов.Ключ);
	КонецЦикла;            

	Для Каждого ИдЗапросПросрочен Из ЗапросыПросрочены Цикл
		//Генерируем сообщение о просроченном запросе, чистим вызов так как уже не ждём ответа, если есть подписка на событие не получен ответ, вызываем.		
		АсинхронноеСбисСобытие		= НовыйАсинхронноеСбисСобытие(ИдЗапросПросрочен, , "Error");
		Сбис3КомандаПросрочена		= АсинхронноеСбисСобытие_ПолучитьПоток(АсинхронноеСбисСобытие);
		
		ИмяКомандыНеполученОтвет	= Сбис3КомандаПросрочена.ОбработчикВызова.ИмяПроцедуры;
		
		Если ИмяКомандыНеполученОтвет = "СбисОтправитьКоманду_Асинхронно" Тогда
			
			ИмяКомандыНеполученОтвет = Сбис3КомандаПросрочена.АргументВызова.Метод;
			
		КонецЕсли;
		
		ОтветПросрочено = НовыйСбисИсключение(775, ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя") + "." + ИмяКомандыНеполученОтвет,,, ИмяКомандыНеполученОтвет + "() не вернул ответ за разумное время");
		
		АсинхронноеСбисСобытие_Установить(АсинхронноеСбисСобытие, "Данные",	ОтветПросрочено);
		АсинхронноеСбисСобытие_ОсвободитьПоток(АсинхронноеСбисСобытие, Сбис3КомандаПросрочена, Истина);
		
		Если Не АсинхроннаяСбисКоманда_ВызватьСобытие(Сбис3КомандаПросрочена, АсинхронноеСбисСобытие) Тогда
			АсинхронноеСбисСобытие_ДобавитьНеобработанныйОтвет(АсинхронноеСбисСобытие);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

//Обрабатываем необработанные в срок ответы, чистим их по времени существования ответа
&НаКлиенте
Процедура ГлобальныйКэш_ОчиститьНевостребованныеОтветы(Аргумент = Неопределено, ДопПараметры = Неопределено) Экспорт
	
	Если Не ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Количество() Тогда
		Возврат;
	КонецЕсли;

	ТочкаПроверки	= ТекущаяДата();
	ДанныеВЛог		= Новый Массив;
	ВремяОжидания	= ПолучитьЗначениеПараметраСбис("ВремяОжиданияОтвета");

	КлючиОтветовНеВостребованы = Новый Массив;
	Для Каждого КлючИЗначениеОтвета Из ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы Цикл
		ИндексКоманд = 0;
		Пока ИндексКоманд < КлючИЗначениеОтвета.Значение.Количество() Цикл
			АсинхронноеСбисСобытие = КлючИЗначениеОтвета.Значение[ИндексКоманд];
			Если ТочкаПроверки - АсинхронноеСбисСобытие.Получено > ВремяОжидания Тогда
				Если ПолучитьЗначениеПараметраСбис("РежимОтладки") Тогда
					//Дампаем в лог необработанные события если надо
					лОтладочныеДанные = Новый Структура("Тип, Модуль, Вызов, Время, Сообщение, Идентификатор");
					лОтладочныеДанные.Модуль		= ПолучитьЗначениеПараметраСбис("ИнтеграцияИмя");
					лОтладочныеДанные.Тип			= АсинхронноеСбисСобытие.Тип;
					лОтладочныеДанные.Идентификатор	= АсинхронноеСбисСобытие.Идентификатор;
					лОтладочныеДанные.Вызов			= "Unknown";
					лОтладочныеДанные.Время			= АсинхронноеСбисСобытие.Получено;
					лОтладочныеДанные.Сообщение		= АсинхронноеСбисСобытие.Данные;

					ДанныеВЛог.Добавить(лОтладочныеДанные);
				КонецЕсли;
				КлючИЗначениеОтвета.Значение.Удалить(ИндексКоманд);
			Иначе
				ИндексКоманд = ИндексКоманд + 1;
			КонецЕсли;
		КонецЦикла;
		Если Не КлючИЗначениеОтвета.Значение.Количество() Тогда
			КлючиОтветовНеВостребованы.Добавить(КлючИЗначениеОтвета.Ключ);
		КонецЕсли;
	КонецЦикла;
	Для Каждого КлючУдалить Из КлючиОтветовНеВостребованы Цикл
		ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Удалить(КлючУдалить);
	КонецЦикла;
	Если ДанныеВЛог.Количество() Тогда
		СохранитьОтладочныеДанныеСБИС(Новый Структура("Log", ДанныеВЛог));
	КонецЕсли;
	
	//Каждую минуту в режиме простоя повторно проверяем оставшиеся невостребованными сообщения, пока не будут почищены все.
	Если ГлобальныйКэш.СБИС.ДанныеИнтеграции.НеизвестныеОтветы.Количество() Тогда
		ПараметрыОтложенногоВызова = Новый Структура("Модуль, Периодичность, ВызватьСразу, ИмяПроцедуры, Аргумент, ИдентификаторДействия", МодульОбъектаКлиент(), 60, Ложь);
		ПараметрыОтложенногоВызова.ИмяПроцедуры				= "ГлобальныйКэш_ОчиститьНевостребованныеОтветы";
		ПараметрыОтложенногоВызова.ИдентификаторДействия	= Новый УникальныйИдентификатор;
		ПодключитьОтложенноеДействие(НовыйОтложенноеДействие(ПараметрыОтложенногоВызова));
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ГлобальныйКэш_КоличествоАктивныхПотоков() Экспорт
	Возврат ГлобальныйКэш.СБИС.ДанныеИнтеграции.Потоки.Количество();
КонецФункции

&НаСервере
Процедура УстановитьПараметрыГлобальногоМодуляВызовСервера(ПараметрыУстановки) Экспорт
	
	ГлобальныйКэшСервер = МодульОбъектаСервер().НовыйГлобальныйКэш();
	Если ПараметрыУстановки.Свойство("Парам") Тогда
		
		ГлобальныйКэшСервер.Парам = ПараметрыУстановки.Парам;
		
	КонецЕсли;
	
	#Если Не Клиент Тогда
		
		ПоместитьВоВременноеХранилище(ГлобальныйКэшСервер, МодульОбъектаСервер().КлючГлобальныйКэшНаСервере());
		
	#КонецЕсли
	
КонецПроцедуры

&НаКлиенте
Процедура ГлобальныйКэш_Вставить(КлассГлобальныйКэш, КлючВставить, ЗначениеВставить) Экспорт

	Если		КлючВставить = "ПараметрыСистемы" Тогда
		
		Для Каждого КлючИЗначениеПараметрСистемы Из ЗначениеВставить Цикл
			
			КлассГлобальныйКэш.ПараметрыСистемы.Вставить(КлючИЗначениеПараметрСистемы.Ключ, КлючИЗначениеПараметрСистемы.Значение);
			
		КонецЦикла;
		
	ИначеЕсли	КлючВставить = "ПараметрыПользователя" Тогда
		
		Для Каждого КлючИЗначениеПараметрСистемы Из ЗначениеВставить Цикл
			
			КлассГлобальныйКэш.Парам.Вставить(КлючИЗначениеПараметрСистемы.Ключ, КлючИЗначениеПараметрСистемы.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ГлобальныйКэш_Получить(ИмяПараметраМодуля) Экспорт
	Перем ЗначениеПараметраМодуля;
	Если 	ГлобальныйКэш = Неопределено Тогда
		ГлобальныйКэш = Новый Структура;
	КонецЕсли;

	Если ИмяПараметраМодуля = "ПараметрыСистемы" Тогда
		Если	ГлобальныйКэш.Свойство(ИмяПараметраМодуля, ЗначениеПараметраМодуля) Тогда
			Возврат ЗначениеПараметраМодуля;
		КонецЕсли;
		ЗначениеПараметраМодуля = ПолучитьПараметрыСистемы();
		ОбновитьПараметрГлобальногоМодуля(ИмяПараметраМодуля, ЗначениеПараметраМодуля);
		Возврат ЗначениеПараметраМодуля;
	ИначеЕсли ИмяПараметраМодуля = "ПараметрыПользователя" Тогда
		Если	ГлобальныйКэш.Свойство("Парам", ЗначениеПараметраМодуля) Тогда
			Возврат ЗначениеПараметраМодуля;
		КонецЕсли;
	ИначеЕсли ИмяПараметраМодуля = "СовместимостьМетодов" Тогда
		
		Возврат ГлобальныйКэш.СовместимостьМетодов;
		
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

&НаКлиенте
Процедура ОбновитьПараметрГлобальногоМодуляДляСервера(ИмяПараметраМодуля, ЗначениеПараметраМодуля = Неопределено)
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		//Глобальный кэш и Глобальный кэш на сервере равны
		Возврат;
		
	#КонецЕсли
	
	
	Если		ЗначениеПараметраМодуля = Неопределено Тогда
		
		ПередачаАдрес = Новый ФиксированнаяСтруктура("Тип, Значение", "Неопределено");
		
	ИначеЕсли	ТипЗнч(ЗначениеПараметраМодуля) = Тип("Строка") Тогда
		
		ПередачаАдрес = Новый ФиксированнаяСтруктура("Тип, Значение", "Строка", ЗначениеПараметраМодуля);
		
	ИначеЕсли	ТипЗнч(ЗначениеПараметраМодуля) = Тип("УникальныйИдентификатор") Тогда 	
		
		ПередачаАдрес = Новый ФиксированнаяСтруктура("Тип, Значение", "УИД", ЗначениеПараметраМодуля);
		
	Иначе
		
		ПередачаАдрес = Новый ФиксированнаяСтруктура("Тип, Значение", "Адрес", ПоместитьВоВременноеХранилище(ЗначениеПараметраМодуля));
		
	КонецЕсли;
	
	ОбновитьПараметрГлобальногоМодуляВызовСервера(ИмяПараметраМодуля, ПередачаАдрес);
	
КонецПроцедуры

&НаСервере
Процедура ОбновитьПараметрГлобальногоМодуляВызовСервера(ИмяПараметраМодуля, ЗначениеПараметраМодуля)
	
	МодульОбъектаСервер().ОбновитьПараметрГлобальногоМодуляНаСервере(ИмяПараметраМодуля, ЗначениеПараметраМодуля);
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьТекущийЛокальныйКэш() Экспорт
	
	Возврат ГлавноеОкно.Кэш;
	
КонецФункции

// Процедура - создаёт экземпляр локального и глобального кэша обработки и связывает модуль объекта и главное окно
//
// Параметры:
//  МодульГлавноеОкно	 - Форма, УправляемаяФорма	 - Форма, куда необходимо прописать локальный кэш и с которой устанавливается привязка текущего модуля  объекта
//
&НаКлиенте
Процедура НастроитьКэшОбработки(МодульГлавноеОкно) Экспорт 
	
	НовыйГлобальныйКэш = НовыйГлобальныйКэш();
	
	ОбновитьПараметрГлобальногоМодуля("ГлавноеОкно",	МодульГлавноеОкно);
	ОбновитьПараметрГлобальногоМодуля("ГлобальныйКэш",	НовыйГлобальныйКэш);
	
	ПараметрыУстановитьКэш	= Новый Структура;
	ПараметрыУстановитьКэш.Вставить("ГлавноеОкно",	 МодульГлавноеОкно);
	ПараметрыУстановитьКэш.Вставить("ГлобальныйКэш", НовыйГлобальныйКэш);
	
	МодульГлавноеОкно.Кэш = НовыйЛокальныйКэш(НовыйГлобальныйКэш);

КонецПроцедуры	

