
////////////////////////Разное//////////////////////
//Функция заменяет в строке недопустимые символы для имени поля структуры

//Функция создает кэш для вызова сервера
&НаКлиенте
Функция КэшДляСервера(Кэш) Экспорт
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Результат = Кэш;
	#Иначе
		КэшПарам = Новый Структура("ИдентификаторСессии, ПолнаяВерсияПродукта, ПроксиСервер, ПроксиПорт, ТипПрокси, ПроксиЛогин, ПроксиПароль");
		ЗаполнитьЗначенияСвойств(КэшПарам, Кэш.Парам);
		Результат = Новый Структура("СБИС,	Парам,	КэшЗначенийИни,	СовместимостьМетодов,	ПараметрыСистемы",  
									Новый Структура("АдресСервера, ПараметрыИнтеграции", Кэш.СБИС.АдресСервера, Кэш.СБИС.ПараметрыИнтеграции),
											КэшПарам, 
													Новый Структура,
																	Новый Структура("HTTPСоединение", Кэш.СовместимостьМетодов.HTTPСоединение),
																							Кэш.ПараметрыСистемы);
		Если Кэш.КэшЗначенийИни.Свойство("КодировкиЧтенияФайлов") Тогда
			Результат.КэшЗначенийИни.Вставить("КодировкиЧтенияФайлов", Кэш.КэшЗначенийИни.КодировкиЧтенияФайлов);
		КонецЕсли;
	#КонецЕсли
	Возврат Результат;
																					
КонецФункции
														
//Функция проверяет регламент из состава пакета и возвращает ключ подходящего мДокумента.
&НаКлиенте
Функция ОпределитьМДокументПоРегламенту(Контекст) Экспорт
	Кэш			= Контекст.Кэш;
	Ини			= Контекст.Ини;
	Вложение	= Контекст.Вложение;
	СоставПакета= Контекст.СоставПакета;
	
	Регламент_Пакет				= Неопределено;
	мДокументРезультат_Ключ		= Неопределено;
	мДокументРезультат_Дефолт	= Неопределено;
	//Получим регламент пакета
	Если	СоставПакета.Свойство("Регламент", Регламент_Пакет)
		И	Регламент_Пакет.Свойство("Название", Регламент_Пакет) Тогда
		Регламент_Пакет = СтрЗаменить(Регламент_Пакет, "'", "");
	КонецЕсли;
	
	//Проверим наличие такого регламента с списке мДокумент, если нет определим по-умолчанию
	Для Каждого КлючИЗначение Из Ини.мДокумент Цикл
		мДокумент_Ключ		= КлючИЗначение.Ключ;
		мДокумент_Значение	= КлючИЗначение.Значение;
		мДокумент_Регламент	= Неопределено;
		Если ЗначениеЗаполнено(Регламент_Пакет) Тогда//Проверяем регламент если он есть. Если нет, берём по-умолчанию
			Если	мДокумент_Значение.Свойство("РеестрСБИС_Операция", мДокумент_Регламент)
				И	мДокумент_Регламент.Свойство("Значение", мДокумент_Регламент) Тогда
				мДокумент_Регламент = СтрЗаменить(мДокумент_Регламент, "'", "");
			КонецЕсли;
			Если мДокумент_Регламент = Регламент_Пакет Тогда
				мДокументРезультат_Ключ = мДокумент_Ключ;
				Прервать;
			КонецЕсли;
		КонецЕсли;
		//По-дефолту берем первый мДокумент, или если есть, то с узлом "ДокументПоУмолчанию"
		Если    мДокументРезультат_Дефолт = Неопределено
			Или(	мДокумент_Значение.Свойство("ДокументПоУмолчанию", мДокумент_Регламент)
			И	мДокумент_Регламент.Свойство("Значение", мДокумент_Регламент)
			И	мДокумент_Регламент = "1") Тогда
			мДокументРезультат_Дефолт = мДокумент_Ключ;
		КонецЕсли;		
	КонецЦикла;
	Результат = Новый Структура("Ключ", мДокументРезультат_Ключ);
	Если Не ЗначениеЗаполнено(Результат.Ключ) Тогда
		Результат.Ключ = мДокументРезультат_Дефолт;
	КонецЕсли;
	Возврат Результат;
КонецФункции

&НаКлиенте
Функция СбисЗаменитьНедопустимыеСимволы(СтрГдеЗаменить) Экспорт
	Возврат	СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрГдеЗаменить,".","_"), " ", ""),"-", "_"),"+", "_"), ",", "_");
КонецФункции

&НаКлиенте
Функция СбисЗаменитьНедопустимыеСимволыДляИмениФайла(СтрГдеЗаменить) Экспорт
	ЗаменаяСлужебныхСиволовWin  = Новый Соответствие;
	ЗаменаяСлужебныхСиволовWin.Вставить(":", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("""", "");
	ЗаменаяСлужебныхСиволовWin.Вставить("/", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("\", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("<", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить(">", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("*", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("?", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить("|", "_");
	ЗаменаяСлужебныхСиволовWin.Вставить(Символы.Таб, " ");  
	
	Результат = СтрГдеЗаменить;
	
	Для Каждого СлужебныйСимвол Из ЗаменаяСлужебныхСиволовWin Цикл
		Результат = СтрЗаменить(Результат, СлужебныйСимвол.Ключ, СлужебныйСимвол.Значение);
	КонецЦикла;                                                         
	
	// Дропаем служебные сиволы. На всякий случай.
	Для КодСимв = 1 По 31 Цикл
		Результат = СтрЗаменить(Результат, Символ(КодСимв), "");
	КонецЦикла;
	
	Возврат	Результат;
КонецФункции

&НаКлиенте
Функция сбисЗаписатьФайл_Клиент(Кэш, сбисОписаниеФайла, Отказ) Экспорт
	РасширениеФайла	= Неопределено;
	ПутьФайла 		= Неопределено;
	ИмяФайла		= Неопределено;
	КодировкаФайла	= Неопределено;
	Если Не сбисОписаниеФайла.Свойство("Расширение", РасширениеФайла) Тогда
		РасширениеФайла	= "txt";
	КонецЕсли;
	Если Не сбисОписаниеФайла.Свойство("Путь", ПутьФайла) Тогда
		ПутьФайла		= КаталогВременныхФайлов();
	Иначе
		Попытка
			СоздатьКаталог(ПутьФайла);
		Исключение
			Отказ = Истина;
			Возврат Новый Структура("code,message,details", 772, "Ошибка работы с файловой системой", "Не удалось создать каталог по пути " + ПутьФайла + ". Детально: " + ИнформацияОбОшибке().Описание);
		КонецПопытки;
	КонецЕсли;
	Если Не сбисОписаниеФайла.Свойство("Имя", ИмяФайла) Тогда
		ИмяФайла		= "tmp_file";
	КонецЕсли;
	Если Не сбисОписаниеФайла.Свойство("Кодировка", КодировкаФайла) Тогда
		КодировкаФайла	= "windows-1251";
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("Имя",		ИмяФайла + "." + РасширениеФайла);
	Результат.Вставить("ПолноеИмя",	ПутьФайла + Результат.Имя);
	//Пока запишем только как тест
	ТекстДок = Новый ТекстовыйДокумент;
	ТекстДок.УстановитьТекст(сбисОписаниеФайла.Данные);
	Попытка
		ТекстДок.Записать(Результат.ПолноеИмя, КодировкаФайла);
	Исключение
		Отказ = Истина;
		Возврат Новый Структура("code,message,details", 772, "Ошибка работы с файловой системой", "Не удалось записать " + Результат.ПолноеИмя + ". Детально: " + ИнформацияОбОшибке().Описание);
	КонецПопытки;
	Возврат Результат;
КонецФункции

//Функция сортирует объект. Возвращает поверхностную(ОФ) отсортированную копию объекта, если он не пуст.
//Пример структуры параметров: {"ПараметрыСортировки": [{"Поле": "Ключ объекта, по которому сортируем", "Направление": "Направление сортировки(Возр/Убыв)"}]}
&НаСервереБезКонтекста
Функция сбисОтсортироватьОбъект(Знач ОбъектКСортировке, Знач ПараметрыСортировки, Отказ) Экспорт
	
	Если Не ОбъектКСортировке.Количество() Тогда
		Возврат ОбъектКСортировке;
	КонецЕсли;
	Результат			= Неопределено;
	ТипОбъект			= Неопределено;
	СтрокаСортировки	= "";
	ТаблицаСортировки	= Новый ТаблицаЗначений;
	ТаблицаСортировки.Колонки.Добавить("Значение_Сортировки");
	//Определим тип результата
	Если		ТипЗнч(ОбъектКСортировке) = Тип("СписокЗначений") Тогда
		Результат = Новый СписокЗначений;
		ТипОбъект = "Список";
	ИначеЕсли   ТипЗнч(ОбъектКСортировке) = Тип("Массив") Тогда
		ТипОбъект = "Массив";
	КонецЕсли;
	//Определим строку сортировки для таблицы, 
	Для Каждого ПолеСортировки Из ПараметрыСортировки.ПоляСортировки Цикл
		СтрокаСортировки = СтрокаСортировки + ?(ПустаяСтрока(СтрокаСортировки), "", ", ") + ПолеСортировки.Поле + ?(ПолеСортировки.Свойство("Направление"), " " + ПолеСортировки.Направление, "");
		ТаблицаСортировки.Колонки.Добавить(ПолеСортировки.Поле);
	КонецЦикла;
	//Заполним поля, по которым проводится сортировка
	Для Каждого ЭлементСортировки Из ОбъектКСортировке Цикл
		ЭлементЗаполнить = ЭлементСортировки;
		Если ТипОбъект = "Список" Или ТипЗнч(ЭлементСортировки) = Тип("КлючИЗначение") Тогда
			ЭлементЗаполнить = ЭлементЗаполнить.Значение;
		КонецЕсли;
		НоваяСтрока = ТаблицаСортировки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ЭлементЗаполнить);
		НоваяСтрока.Значение_Сортировки = ЭлементСортировки;
	КонецЦикла;
	ТаблицаСортировки.Сортировать(СтрокаСортировки);
	
	//Формируем результат
	КолонкаСортировки = ТаблицаСортировки.ВыгрузитьКолонку("Значение_Сортировки");
	Если ТипОбъект = "Массив" Тогда
		Результат = КолонкаСортировки;
	Иначе
		Для Каждого ЭлементСортировки Из КолонкаСортировки Цикл
			Если ТипОбъект = "Список" Тогда
				Результат.Добавить(ЭлементСортировки.Значение, ЭлементСортировки.Представление, ЭлементСортировки.Пометка, ЭлементСортировки.Картинка);
			Иначе
				Результат.Добавить(ЭлементСортировки);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

//Функция возвращает элемент по пути
&НаКлиенте
Функция СбисПолучитьЭлементФормы(Кэш, ОтЭлемента = Неопределено, СбисПутьЭлемента) Экспорт
	ИмяЭлементаРазбивка = СтрЗаменить(СбисПутьЭлемента, ".", Символы.ПС);
	СчетчикРазбивки = 1;
	Если ОтЭлемента = Неопределено Тогда
		Результат = Кэш.ГлавноеОкно;
	Иначе
		Результат = ОтЭлемента;
	КонецЕсли;
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Если ТипЗнч(Результат) = Тип("Форма") Тогда
			Результат = Результат.ЭлементыФормы;
		КонецЕсли;
	#Иначе
		Если ТипЗнч(Результат) = Тип("УправляемаяФорма") Тогда
			Результат = Результат.Элементы.Найти(СтрПолучитьСтроку(ИмяЭлементаРазбивка, 1));
			СчетчикРазбивки = СчетчикРазбивки + 1;
		КонецЕсли;
	#КонецЕсли
	Для СчетчикРазбивки = СчетчикРазбивки По СтрЧислоСтрок(ИмяЭлементаРазбивка) Цикл
		Если Результат = Неопределено Тогда
			Прервать;
		КонецЕсли;
		КлючПути = СтрПолучитьСтроку(ИмяЭлементаРазбивка, СчетчикРазбивки);
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Если	ТипЗнч(Результат) = Тип("ТаблицаЗначений")
				Или	ТипЗнч(Результат) = Тип("ТабличноеПоле") Тогда
				Результат = Результат["Колонки"];
			ИначеЕсли ТипЗнч(Результат) = Тип("Панель") Тогда
				Результат = Результат["Страницы"];
			ИначеЕсли  ТипЗнч(Результат) = Тип("СтраницаПанели") Тогда
				Если ОтЭлемента = Неопределено Тогда
					Результат = Кэш.ГлавноеОкно.ЭлементыФормы;
				ИначеЕсли ТипЗнч(ОтЭлемента) = Тип("Форма") Тогда
					Результат = ОтЭлемента.ЭлементыФормы;
				Иначе
					Результат = ОтЭлемента;
				КонецЕсли;
			КонецЕсли;
		#Иначе	
			Результат = Результат["ПодчиненныеЭлементы"];
		#КонецЕсли
		Если КлючПути = "Страницы" Тогда
			Продолжить;
		КонецЕсли;
		Результат = Результат.Найти(КлючПути);
	КонецЦикла;	
	Возврат Результат;
КонецФункции

//Процедура копирует структуру в контексте сервера. Использовать ТОЛЬКО для серверных функций и процедур	
&НаСервереБезКонтекста
Процедура сбисСкопироватьСтруктуру(СтруктураКуда, Знач СтруктураОткуда)  Экспорт
	СбисСкопироватьСтруктуруСПараметрами(СтруктураКуда, СтруктураОткуда, Новый Структура("КлючиНеКопировать", Новый Массив));
КонецПроцедуры

//Процедура копирует структуру в контексте сервера. Использовать ТОЛЬКО для серверных функций и процедур	
&НаСервереБезКонтекста
Процедура СбисСкопироватьСтруктуруСПараметрами(СтруктураКуда, Знач СтруктураОткуда, Знач ДопПараметры)
	Если НЕ ТипЗнч(СтруктураОткуда) =  Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	Для Каждого Элемент Из СтруктураОткуда Цикл	
		Если Не ДопПараметры.КлючиНеКопировать.Найти(Элемент.Ключ) = Неопределено Тогда
			Если Не СтруктураКуда.Свойство(Элемент.Ключ) Тогда
				СтруктураКуда.Вставить(Элемент.Ключ,Элемент.Значение);
			Иначе
				СтруктураКуда[Элемент.Ключ] = Элемент.Значение;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Структура") Тогда
			СтруктураКуда.Вставить(Элемент.Ключ, Новый Структура);
			сбисСкопироватьСтруктуру(СтруктураКуда[Элемент.Ключ], Элемент.Значение);
		ИначеЕсли ТипЗнч(Элемент.Значение) =  Тип("Массив") Тогда
			СтруктураКуда.Вставить(Элемент.Ключ, Новый Массив);
			Для Каждого ЭлементМассива Из Элемент.Значение Цикл
				ПромежуточнаяСтруктура = Новый Структура;
				сбисСкопироватьСтруктуру(ПромежуточнаяСтруктура, ЭлементМассива);
				СтруктураКуда[Элемент.Ключ].Добавить(ПромежуточнаяСтруктура);
			КонецЦикла;
		ИначеЕсли Не СтруктураКуда.Свойство(Элемент.Ключ) Тогда
			СтруктураКуда.Вставить(Элемент.Ключ,Элемент.Значение);
		Иначе
			СтруктураКуда[Элемент.Ключ] = Элемент.Значение;			
		КонецЕсли;
	КонецЦикла;	
КонецПроцедуры

//Функция возвращает глубокую копию исходного объекта. Поддерживаемые составные типы: Структура, Массив.
&НаСервереБезКонтекста
Функция СбисСкопироватьОбъект(Знач ОбъектНаВход)  Экспорт
	Возврат СкопироватьОбъектСПараметрамиСервер(ОбъектНаВход);
КонецФункции

//Функция возвращает глубокую копию исходного объекта. Поддерживаемые составные типы: Структура, Массив.
&НаКлиенте
Функция СбисСкопироватьОбъектНаКлиенте(ОбъектНаВход)  Экспорт
	Если ТипЗнч(ОбъектНаВход) = Тип("Структура") Тогда
		Результат = Новый Структура;
		Для Каждого КлючИЗначение Из ОбъектНаВход Цикл
			Результат.Вставить(КлючИЗначение.Ключ, сбисСкопироватьОбъектНаКлиенте(КлючИЗначение.Значение));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОбъектНаВход) = Тип("Массив") Тогда
		Результат = Новый Массив;
		Для Каждого ЭлементМассива Из ОбъектНаВход Цикл
			Результат.Добавить(сбисСкопироватьОбъектНаКлиенте(ЭлементМассива));
		КонецЦикла;
	Иначе
		Результат = ОбъектНаВход;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Функция возвращает глубокую копию раздела ини без копии расчитанных значений. 
//Поддерживаемые составные типы: Структура, Массив.
//ДопПараметры: КлючиНеКопировать - массив ключей, значения которых не копируются, а переносятся как есть.
&НаСервереБезКонтекста
Функция СкопироватьОбъектСПараметрамиСервер(Знач СбисОбъект, СбисКлючи=Неопределено, ГлубокоеКопирование=Истина) Экспорт
	Если ТипЗнч(СбисОбъект) = Тип("Структура") Тогда
		Если СбисКлючи = Неопределено Тогда
			Результат = Новый Структура;
			Для Каждого КлючИЗначение Из СбисОбъект Цикл
				Результат.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				Если ГлубокоеКопирование Тогда
					Результат[КлючИЗначение.Ключ] = СкопироватьОбъектСПараметрамиСервер(КлючИЗначение.Значение,,ГлубокоеКопирование)			
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат = Новый Структура(СбисКлючи);
			ЗаполнитьЗначенияСвойств(Результат, СбисОбъект);
			Если ГлубокоеКопирование Тогда
				Для Каждого КлючИЗначение Из Результат Цикл
					Результат[КлючИЗначение.Ключ] = СкопироватьОбъектСПараметрамиСервер(КлючИЗначение.Значение,,ГлубокоеКопирование)
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ТипЗнч(СбисОбъект) = Тип("Массив") Тогда
		Результат = Новый Массив;
		Если СбисКлючи = Неопределено Тогда
			Для Каждого ЭлементМассива Из СбисОбъект Цикл
				Результат.Добавить(?(ГлубокоеКопирование, СкопироватьОбъектСПараметрамиСервер(ЭлементМассива,,ГлубокоеКопирование), ЭлементМассива));
			КонецЦикла;
		Иначе
			Для Счетчик = 0 По СбисОбъект.Количество() Цикл
				Если СбисКлючи.Найти(Счетчик) Тогда
					Результат.Добавить(?(ГлубокоеКопирование, СкопироватьОбъектСПараметрамиСервер(ЭлементМассива,,ГлубокоеКопирование), ЭлементМассива));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Результат = СбисОбъект;
	КонецЕсли;
	Возврат Результат;
КонецФункции

&НаКлиенте
Функция СкопироватьОбъектСПараметрамиКлиент(СбисОбъект, СбисКлючи=Неопределено, ГлубокоеКопирование=Истина) Экспорт
	Если ТипЗнч(СбисОбъект) = Тип("Структура") Тогда
		Если СбисКлючи = Неопределено Тогда
			Результат = Новый Структура;
			Для Каждого КлючИЗначение Из СбисОбъект Цикл
				Результат.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				Если ГлубокоеКопирование Тогда
					Результат[КлючИЗначение.Ключ] = СкопироватьОбъектСПараметрамиКлиент(КлючИЗначение.Значение,,ГлубокоеКопирование)			
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат = Новый Структура(СбисКлючи);
			ЗаполнитьЗначенияСвойств(Результат, СбисОбъект);
			Если ГлубокоеКопирование Тогда
				Для Каждого КлючИЗначение Из Результат Цикл
					Результат[КлючИЗначение.Ключ] = СкопироватьОбъектСПараметрамиКлиент(КлючИЗначение.Значение,,ГлубокоеКопирование)
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ТипЗнч(СбисОбъект) = Тип("Массив") Тогда
		Результат = Новый Массив;
		Если СбисКлючи = Неопределено Тогда
			Для Каждого ЭлементМассива Из СбисОбъект Цикл
				Результат.Добавить(?(ГлубокоеКопирование, СкопироватьОбъектСПараметрамиКлиент(ЭлементМассива,,ГлубокоеКопирование), ЭлементМассива));
			КонецЦикла;
		Иначе
			Для Счетчик = 0 По СбисОбъект.Количество() Цикл
				Если СбисКлючи.Найти(Счетчик) Тогда
					Результат.Добавить(?(ГлубокоеКопирование, СкопироватьОбъектСПараметрамиКлиент(ЭлементМассива,,ГлубокоеКопирование), ЭлементМассива));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Результат = СбисОбъект;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Функция возвращает представление сертификата для формы ввода пинкода
&НаКлиенте
Функция СформироватьЗаголовокСертификатаДляФормыВвода(Кэш, Сертификат) Экспорт
	сбисСертификатИмя = СокращенноеФИО(Кэш, Сертификат.ФИО);
	Если Сертификат.Свойство("Должность") Тогда
		сбисСертификатИмя = сбисСертификатИмя + "(" + Сертификат.Должность + ")"
	КонецЕсли;
	сбисСертификатИмя = сбисСертификатИмя + ", "  + Сертификат.Название;
	Если Сертификат.Свойство("ИНН") Тогда
		сбисСертификатИмя = сбисСертификатИмя + "(ИНН " + Сертификат.ИНН + ")"
	КонецЕсли;
	Возврат сбисСертификатИмя;
КонецФункции

//UAA Убрал экспорт для серверной функции дабы избежать лишних вызовов при разработке внешних функций. Использовать РазбитьСтрокуВМассивНаКлиенте(). А ещё лучше сразу СтрЗаменить()
//Функция разбивает строку по разделителю в массив
&НаСервереБезКонтекста
Функция РазбитьСтрокуВМассив(Знач сбисСтрока, сбисРазделитель=".")
	Результат = Новый Массив();	
	МногоуровневаяСтрока = СтрЗаменить(сбисСтрока, сбисРазделитель, Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(МногоуровневаяСтрока) Цикл 
		Результат.Добавить(СокрЛП(СтрПолучитьСтроку(МногоуровневаяСтрока, НомерСтроки)));
	КонецЦикла;
	Возврат Результат;
КонецФункции

//Функция разбивает строку по разделителю в массив в контексте клиента
&НаКлиенте
Функция РазбитьСтрокуВМассивНаКлиенте(сбисСтрока, сбисРазделитель=".") Экспорт 
	Результат = Новый Массив();	
	МногоуровневаяСтрока = СтрЗаменить(сбисСтрока, сбисРазделитель, Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(МногоуровневаяСтрока) Цикл 
		Результат.Добавить(СокрЛП(СтрПолучитьСтроку(МногоуровневаяСтрока, НомерСтроки)));
	КонецЦикла;
	Возврат Результат;
КонецФункции

//Процедура дозаполняет структуру данными из другой структуры в контексте клиента	
&НаКлиенте
Процедура сбисСкопироватьСтруктуруНаКлиенте(СтруктураКуда, СтруктураОткуда)  Экспорт
	ТипМассив = Тип("Массив");
	ТипСтруктура = Тип("Структура");
	Для Каждого Элемент Из СтруктураОткуда Цикл	
		Если ТипЗнч(СтруктураОткуда) = ТипМассив Тогда
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = ТипСтруктура Тогда
			СтруктураКуда.Вставить(Элемент.Ключ, Новый Структура);
			сбисСкопироватьСтруктуруНаКлиенте(СтруктураКуда[Элемент.Ключ], Элемент.Значение);				
		ИначеЕсли ТипЗнч(Элемент.Значение) = ТипМассив Тогда
			СтруктураКуда.Вставить(Элемент.Ключ, Новый Массив);
			Для Каждого ЭлементМассива Из Элемент.Значение Цикл
				ПромежуточнаяСтруктура = Новый Структура;
				сбисСкопироватьСтруктуруНаКлиенте(ПромежуточнаяСтруктура, ЭлементМассива);
				СтруктураКуда[Элемент.Ключ].Добавить(ПромежуточнаяСтруктура);
			КонецЦикла;
		ИначеЕсли Не СтруктураКуда.Свойство(Элемент.Ключ) Тогда
			СтруктураКуда.Вставить(Элемент.Ключ,Элемент.Значение);
		Иначе
			СтруктураКуда[Элемент.Ключ] = Элемент.Значение;			
		КонецЕсли;
	КонецЦикла;	
КонецПроцедуры

&НаКлиенте
Функция СбисТекущаяДатаВМиллисекундах(Кэш) Экспорт

	Возврат МодульОбъектаКлиент().ПолучитьДатуВМиллисекундах();

КонецФункции

&НаКлиенте
Функция СбисФорматРазделителя(ПараметрыКаталога) Экспорт
	Если ПараметрыКаталога.ЭтоLinux Тогда
		Возврат "/";
	КонецЕсли;
	Возврат "\";
КонецФункции

//Функция выполняет обработку строк в зависимости от режима
&НаКлиенте
Функция СбисФорматСтроки(СбисСтрока, Режим="Убрать", ФорматнаяСтрока="@/-?=\& ""'#№*(:|;).") Экспорт
	Если		Режим = "Убрать" Тогда
		СбисНоваяСтрока	= СбисСтрока;
		Для	шаг	= 1	По СтрДлина(ФорматнаяСтрока) Цикл
			СбисНоваяСтрока	= СтрЗаменить(СбисНоваяСтрока, Сред(ФорматнаяСтрока, шаг, 1), "");
		КонецЦикла;
	ИначеЕсли	Режим = "КлючСтруктуры" Тогда
		СбисНоваяСтрока = СбисФорматСтроки(СбисСтрока);
		Если Найти("0123456789", Лев(СбисНоваяСтрока, 1)) Тогда//Первый символ - число. Добавить префикс(в структуре ключ не может начинаться с числа)
			СбисНоваяСтрока = "_" + СбисНоваяСтрока;
		КонецЕсли;
	Иначе
		СбисНоваяСтрока = СбисСтрока;
	КонецЕсли;
	Возврат СбисНоваяСтрока;
КонецФункции

//Процедура завершает работу в СБИС
//Структура ошибки при отказе, Истина при успешном завершении
&НаКлиенте
Функция СбисЗавершениеРаботы(Кэш, Отказ) Экспорт
	Попытка
		МодульОбъектаКлиент().СохранитьМеткиСтатусов(Кэш);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Кэш.ГлавноеОкно.СбисСообщитьОбОшибке(Кэш, СбисИсключение(ИнформацияОбОшибке, "РаботаСДокументами1С.СбисФорматСтроки"));
	КонецПопытки;
	Если Кэш.ТекущийСеанс.Свойство("ЗавершитьПлагин") И Кэш.ТекущийСеанс.ЗавершитьПлагин = Истина Тогда
		Кэш.Сбис.ДанныеИнтеграции.Объекты.Форма_ExtSDK.СБИСПлагин_Завершить(Кэш);
	КонецЕсли;
	Если Кэш.ТекущийСеанс.Свойство("ВременныеФайлы") Тогда 
		Кэш.ТекущийСеанс.ВременныеФайлы.Параметры.ВремяЖизни = 0;
		СбисОчиститьВременныеФайлы();
		ЭтаФорма.ОтключитьОбработчикОжидания("СбисОчиститьВременныеФайлы");
	КонецЕсли;
	Кэш.ГлавноеОкно.ОтключитьОбработчикОжидания("ВыполнениеОтложенныхПроцедур");
	МестныйКэш.Интеграция.Завершить(Кэш, Новый Структура, Отказ);
	Возврат Истина;
КонецФункции

//Очищалка для временных файлов
&НаКлиенте
Процедура СбисОчиститьВременныеФайлы() Экспорт
	Если Не МестныйКэш.ТекущийСеанс.Свойство("ВременныеФайлы") Тогда
		Возврат;
	КонецЕсли;
	СбисВремяПроверки = ТекущаяДата();
	МассивФайловУдалены = Новый Массив;
	Для Каждого КлючИЗначение Из МестныйКэш.ТекущийСеанс.ВременныеФайлы.Файлы Цикл
		Если Не	КлючИЗначение.Значение.Освободить
			И	СбисВремяПроверки - КлючИЗначение.Значение.ВремяПолучения < МестныйКэш.ТекущийСеанс.ВременныеФайлы.Параметры.ВремяЖизни Тогда
			Продолжить;
		КонецЕсли;
		Попытка
			Файл = Новый Файл(КлючИЗначение.Ключ);
			Если Файл.Существует() Тогда
				УдалитьФайлы(КлючИЗначение.Ключ);
			КонецЕсли;
			МассивФайловУдалены.Добавить(КлючИЗначение.Ключ);
		Исключение
		КонецПопытки;
	КонецЦикла;
	Для Каждого ЭлементУдален Из МассивФайловУдалены Цикл
		МестныйКэш.ТекущийСеанс.ВременныеФайлы.Файлы.Удалить(ЭлементУдален);
	КонецЦикла;
	
	Если МестныйКэш.ТекущийСеанс.ВременныеФайлы.Файлы.Количество() Тогда
		ЭтаФорма.ПодключитьОбработчикОжидания("СбисОчиститьВременныеФайлы", 300, Истина);
	КонецЕсли;
КонецПроцедуры

//Создает временный файл. Подключает обработчик ожидания, который очищает файлы по истечении их срока жизни.
&НаКлиенте
Функция СбисПолучитьИмяВременногоФайлаКлиент(Расширение="tmp") Экспорт
	Перем СбисВременныеФайлы;
	Если НЕ МестныйКэш.ТекущийСеанс.Свойство("ВременныеФайлы", СбисВременныеФайлы) Тогда
		СбисВременныеФайлы = Новый Структура("Файлы, Параметры", Новый Соответствие, Новый Структура("ВремяЖизни", 3600));
		МестныйКэш.ТекущийСеанс.Вставить("ВременныеФайлы", СбисВременныеФайлы);
	КонецЕсли;
	#Если ВебКлиент Тогда
		ИмяФайла = КаталогВременныхФайлов() + "sbis_" + Строка(Новый УникальныйИдентификатор()) + "." + СтрЗаменить(Расширение, ".", "");
	#Иначе
		ИмяФайла = ПолучитьИмяВременногоФайла(Расширение);
	#КонецЕсли
	СбисВременныеФайлы.Файлы.Вставить(ИмяФайла, Новый Структура("ВремяПолучения, Освободить", ТекущаяДата(), Ложь));
	ЭтаФорма.ПодключитьОбработчикОжидания("СбисОчиститьВременныеФайлы", 60, Истина);
	Возврат ИмяФайла;
КонецФункции

//Очищает временный файл
&НаКлиенте
Процедура СбисОчиститьВременныйФайлКлиент(ИмяФайла) Экспорт
	Перем СбисВременныеФайлы;
	Если	Не МестныйКэш.ТекущийСеанс.Свойство("ВременныеФайлы", СбисВременныеФайлы)
		Или	СбисВременныеФайлы.Файлы.Получить(ИмяФайла) = Неопределено Тогда
		Возврат
	КонецЕсли;
	Попытка
		УдалитьФайлы(ИмяФайла);
	Исключение
	КонецПопытки;
	СбисВременныеФайлы.Файлы.Удалить(ИмяФайла);
КонецПроцедуры

&НаКлиенте
Функция СбисФорматКаталога(КаталогПуть, ПараметрыКаталога) Экспорт
	сРазделитель = СбисФорматРазделителя(ПараметрыКаталога);
	Возврат КаталогПуть + ?(Прав(КаталогПуть, 1) = сРазделитель, "", сРазделитель);	
КонецФункции

//Функция возвращает истину, либо ложь для номенклатуры
&НаСервереБезКонтекста
Функция сбисНоменклатура1СУслуга_Сервер(Знач Контекст)
	Возврат	ЗначениеЗаполнено(Контекст.Номенклатура)
	И	Контекст.Номенклатура.Услуга = Истина; // Может прийти со значением null, непонятно почему
КонецФункции

//OLD использовать НоваяВерсияБольшеКлиент
// Функция проверяет, является ли текущая версия обработки или SDK новой по отношению к предыдущей запущенной	
&НаКлиенте
Функция ЭтоНоваяВерсия(НоваяВерсия, СтараяВерсия, ВерсияСильноУстарела = Ложь) Экспорт
	Если Не ЗначениеЗаполнено(СтараяВерсия) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтрНоваяВерсия = СтрЗаменить(НоваяВерсия, ".", Символы.ПС);
	СтрСтараяВерсия= СтрЗаменить(СтараяВерсия, ".", Символы.ПС);
	сЧислоРазрядов = Макс(СтрЧислоСтрок(СтрНоваяВерсия),СтрЧислоСтрок(СтрСтараяВерсия));
	Для сч = 1 По сЧислоРазрядов Цикл
		ЗначениеРазрядаНов = СтрПолучитьСтроку(СтрНоваяВерсия, сч);
		ЗначениеРазрядаСтар = СтрПолучитьСтроку(СтрСтараяВерсия, сч);
		Попытка
			ЗначениеРазрядаНов = Число(ЗначениеРазрядаНов);
		Исключение
			ЗначениеРазрядаНов = 0;
		КонецПопытки;
		Попытка
			ЗначениеРазрядаСтар = Число(ЗначениеРазрядаСтар);
		Исключение
			ЗначениеРазрядаСтар = 0;
		КонецПопытки;
		
		Если ЗначениеРазрядаНов > ЗначениеРазрядаСтар Тогда
			Если	сч = 1 
				ИЛИ	(сч = 2 И ЗначениеРазрядаНов - ЗначениеРазрядаСтар > 1) Тогда
				ВерсияСильноУстарела = Истина;
			КонецЕсли;
			Возврат Истина;
		ИначеЕсли ЗначениеРазрядаНов = ЗначениеРазрядаСтар Тогда
			Продолжить;
		КонецЕсли;
		Прервать;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

//Функция сериализует версию из формата 1С в формат Число и обратно. Пример в 1С: 3.0.40.40, пример в число: 3 0000 0040 0040
&НаКлиенте                                  
Функция СериализоватьВерсию(Версия, Направление="ЧислоВСтроку",ДополнительныеПараметры=Неопределено) Экспорт
	
	Если ДополнительныеПараметры = Неопределено	Тогда
		ДополнительныеПараметры	= Новый	Структура;
	КонецЕсли;
	Разделитель		= ?(ДополнительныеПараметры.Свойство("Разделитель"),	ДополнительныеПараметры.Разделитель,	".");
	Заполнитель		= ?(ДополнительныеПараметры.Свойство("Заполнитель"),	ДополнительныеПараметры.Заполнитель,	"0");
	Разрядность		= ?(ДополнительныеПараметры.Свойство("Разрядность"),	ДополнительныеПараметры.Разрядность,	4);
	ЧислоРазрядов	= ?(ДополнительныеПараметры.Свойство("ЧислоРазрядов"),	ДополнительныеПараметры.ЧислоРазрядов,	4);
	Результат		= "";
	
	СтрокаВерсии	= СокрЛП(СтрЗаменить(Формат(Версия, "ЧН=0; ЧГ=0"), Символы.НПП, ""));
	
	Если		Направление	= "СтрокуВЧисло" Тогда//Переводит из формата 1.1.1.1 в число 1 0001 0001 0001
		МногоуровневаяСтрока = СтрЗаменить(СтрокаВерсии, Разделитель, Символы.ПС);
		Для шаг = 2 По СтрЧислоСтрок(МногоуровневаяСтрока) Цикл
			СтрокаРазряда = СтрПолучитьСтроку(МногоуровневаяСтрока, шаг);
			Пока СтрДлина(СтрокаРазряда) < Разрядность Цикл
				СтрокаРазряда = Заполнитель + СтрокаРазряда;
			КонецЦикла;
			Результат = Результат + СтрокаРазряда;
		КонецЦикла;
		Результат = СтрПолучитьСтроку(МногоуровневаяСтрока, 1)	+ Результат;
		Результат = Число(Результат);
	ИначеЕсли	Направление	= "ЧислоВСтроку" Тогда//Переводит из формата числа 1 0001 0001 0001 в 1.1.1.1
		Если СтрЧислоВхождений(СтрокаВерсии, Разделитель) = ЧислоРазрядов - 1 Тогда//версия уже сериализована.
			Возврат	СтрокаВерсии;
		КонецЕсли;
		ДробЧислоРазрядов	= СтрДлина(СтрокаВерсии) / Разрядность;
		ЦелЧислоРазрядов	= ?(Цел(ДробЧислоРазрядов) = ДробЧислоРазрядов, ДробЧислоРазрядов, Цел(ДробЧислоРазрядов)	+ 1);
		
		Для шаг = 1 По ЦелЧислоРазрядов Цикл
			Если СтрДлина(СтрокаВерсии) > Разрядность * шаг Тогда 
				СтрокаРазряда	= Сред(СтрокаВерсии, (СтрДлина(СтрокаВерсии)	- Разрядность*шаг)+1, Разрядность);
			Иначе
				СтрокаРазряда	= Сред(СтрокаВерсии, 1, Разрядность-(Разрядность*шаг-СтрДлина(СтрокаВерсии)));
			КонецЕсли;
			Пока	Лев(СтрокаРазряда, 1) = Заполнитель
				И	СтрДлина(СтрокаРазряда) > 1	Цикл
				СтрокаРазряда	= Сред(СтрокаРазряда, 2);
			КонецЦикла;
			Результат	= Разделитель	+ СтрокаРазряда	+ Результат;
		КонецЦикла;
		Если ЧислоРазрядов > ЦелЧислоРазрядов Тогда
			Для	шаг = 1 По ЧислоРазрядов - ЦелЧислоРазрядов	Цикл
				Результат = Разделитель	+ Заполнитель + Результат;
			КонецЦикла;
		КонецЕсли;
		Если Лев(Результат, 1) = Разделитель Тогда
			Результат = Сред(Результат, 2);
		КонецЕсли;
	ИначеЕсли	Направление	= "Дозаполнить"	Тогда//дозаполнение версии до стандарта. Пример: версия 1.1.1 станет 1.1.1.0
		ВспомогательныйРазделитель	= ?(ДополнительныеПараметры.Свойство("ВспомогательныйРазделитель"), ДополнительныеПараметры.ВспомогательныйРазделитель, "-");
		шаг = 0;
		Если Не ПустаяСтрока(СтрокаВерсии) Тогда
			МногоСтрочнаяЗапись = СтрЗаменить(СтрокаВерсии, ВспомогательныйРазделитель, Символы.ПС);
			Пока шаг < СтрЧислоСтрок(МногоСтрочнаяЗапись) Цикл
				шаг = шаг + 1;
				Результат = Результат + СтрПолучитьСтроку(МногоСтрочнаяЗапись, шаг)	+ Разделитель;
			КонецЦикла;
		КонецЕсли;
		Пока шаг < ЧислоРазрядов Цикл//Дозаполнить недостающие разряды
			шаг = шаг + 1;
			Результат = Результат + "0" + Разделитель;
		КонецЦикла;
		Результат = Лев(Результат, СтрДлина(Результат) - СтрДлина(Разделитель));
	КонецЕсли;
	
	Возврат	Результат;
	
КонецФункции

//Функция формирует действие для выполнения аннулирования. ДействиеАннулировать - структура. 
&НаКлиенте
Функция СформироватьЗапросНаАннулирование(Кэш, ПараметрыЗапроса, Отказ) Экспорт
	РезультатЗапроса	= Новый Структура("Действие, Этап");
	ЭтапАннулирование	= Новый Структура("Название, Действие", "Аннулирование");
	Если Не ПараметрыЗапроса.Свойство("Действие", ЭтапАннулирование.Действие) Тогда
		ЭтапАннулирование.Действие = Новый Структура("Название", "Аннулировать");
	КонецЕсли;
	ПараметрыВыбор		= Новый Структура("Этап, ВернутьОшибку, СообщатьПриОшибке", ЭтапАннулирование, Истина, Ложь);
	
	РезультатЧтенияПакета = МестныйКэш.Интеграция.ПрочитатьДокумент(МестныйКэш, ПараметрыЗапроса.ИдентификаторПакета, ПараметрыВыбор, Отказ);
	Если Отказ Тогда
		Возврат РезультатЧтенияПакета;
	КонецЕсли;
	//После чтения запроса, найдем нужное действие в ответе - оно и будет искомым вариантом.
	ЭтапАннулированиеОтвет = Неопределено;
	Для Каждого РезультатЭтап Из РезультатЧтенияПакета.Этап Цикл
		Если РезультатЭтап.Название = ЭтапАннулирование.Название Тогда
			РезультатЗапроса.Этап = РезультатЭтап;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если РезультатЗапроса.Этап = Неопределено Тогда
		Отказ = Истина;
		Возврат Новый Структура("code, message, details", 100, "Неизвестная ошибка системы", "Не удалось сформировать запрос на аннулирование документа!")
	КонецЕсли;
	Для Каждого РезультатДействие Из РезультатЗапроса.Этап.Действие Цикл
		Если РезультатДействие.Название = ЭтапАннулирование.Действие.Название Тогда
			РезультатЗапроса.Действие = РезультатДействие;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если РезультатЗапроса.Действие = Неопределено Тогда
		Отказ = Истина;
		Возврат Новый Структура("code, message, details", 100, "Неизвестная ошибка системы", "Не удалось сформировать запрос на аннулирование документа!")
	КонецЕсли;
	Возврат РезультатЗапроса;
КонецФункции

// Функция сохраняет пакет документов на диск
//
// Параметры:
//  Кэш		 - Структура	- Кэш обработки
//  Контекст - Структура	- Контекст рассчитываемого документа 
//
&НаКлиенте
Функция СохранитьПакетНаДиск(Кэш, Контекст) Экспорт
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(Контекст.СоставПакета);
	СохранитьПакетыНаДиск(Кэш, СписокСтрок);  
	
КонецФункции

//функция сохраняет пакеты документов на диск
&НаКлиенте
Функция СохранитьПакетыНаДиск(Кэш, СписокСтрок) Экспорт
	КаталогВыгрузкиФайлов = "";
	ДиалогОткрытия = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога); 
	ДиалогОткрытия.Заголовок = "Выберите каталог выгрузки";
	Если ДиалогОткрытия.Выбрать() Тогда
		КаталогВыгрузкиФайлов = ДиалогОткрытия.Каталог;//Исправлена ошибка при массовом сохранении документов. 
	КонецЕсли;
	
	Если КаталогВыгрузкиФайлов <> "" Тогда
		ВремКаталог = КаталогВременныхФайлов();
		Сч = 0;
		
		Для каждого СтрокаИзСписка из СписокСтрок Цикл
			Сч = Сч + 1;			
			сбисПоказатьСостояние("Сохранение файлов", Кэш.ГлавноеОкно, Окр(100*Сч / СписокСтрок.Количество(), 0));
			
			Результат = Кэш.Интеграция.ПрочитатьДокумент(Кэш,СтрокаИзСписка.Идентификатор);	

			Если СтрокаИзСписка.Свойство("Название") Тогда
				ЗаголовокПакета = СтрокаИзСписка.Название; 
			Иначе
				ЗаголовокПакета = Результат.Название;
			КонецЕсли;  

			ИмяZIP = СтрЗаменить(ЗаголовокПакета,":",".");
			ИмяZIP = СтрЗаменить(ИмяZIP,"\","_");
			ИмяZIP = СтрЗаменить(ИмяZIP,"/","_");
			КаталогВыгрузки = КаталогВыгрузкиФайлов+"\"+ИмяZip;
			СоздатьКаталог(КаталогВыгрузки);
			СоздатьКаталог(КаталогВыгрузки+"\PDF");
			
			//Сохраним архив пакета во временный каталог
			URL = Результат.СсылкаНаАрхив;		
			ПолноеИмяФайла = КаталогВыгрузки + "\" + ИмяZIP + ".zip";
			Кэш.Интеграция.СохранитьВложениеПоСсылкеВФайл(Кэш,URL,ПолноеИмяФайла);
			
			//Добавим в новый архив pdf-файлы
			СписокФайлов = Новый СписокЗначений;
			Вложения = Результат.Вложение;
			Если Вложения= Неопределено Тогда
				Сообщить("В пакете "+ЗаголовокПакета+" отсутствуют вложения");
				сбисСпрятатьСостояние(ЭтаФорма);
				Продолжить;
			КонецЕсли;
			МассивВложений = Новый Массив;
			Для СчВложений = 0 по Вложения.Количество() - 1 Цикл
				Если Вложения[СчВложений].Служебный = "Да" Тогда
					Продолжить;
				КонецЕсли;	
				Если Вложения[СчВложений].Свойство("Зашифрован") и Вложения[СчВложений].Зашифрован = "Да" Тогда
					Продолжить;
				КонецЕсли;
				URL = Вложения[СчВложений].СсылкаНаPDF;
				ИмяФайла = Вложения[СчВложений].Файл.Имя;
				ИмяФайла = СтрЗаменить(ИмяФайла,".xml","");
				ИмяФайла = СтрЗаменить(ИмяФайла,".XML","");
				ИмяФайла = СтрЗаменить(ИмяФайла,":",".");
				ИмяФайла = СтрЗаменить(ИмяФайла,"\","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,"/","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,"*","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,"?","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,">","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,"<","_");
				ИмяФайла = СтрЗаменить(ИмяФайла,"+","_");
				
				ПолноеИмяФайлаПДФ = КаталогВыгрузки+"\PDF" + "\" + ИмяФайла + ".pdf";			
				Если URL <> "" Тогда						
					Кэш.Интеграция.СохранитьВложениеПоСсылкеВФайл(Кэш,URL,ПолноеИмяФайлаПДФ);
				КонецЕсли;								
			КонецЦикла;
			
		КонецЦикла;	
		сбисСпрятатьСостояние(Кэш.ГлавноеОкно);
	КонецЕсли;
	
КонецФункции

//Функция сохраняет в каталог текстовый документ с данными о системе, версии и настройках ВО, а также установленные настройки 
&НаКлиенте
Функция СбисСформироватьОбщуюИнформациюДляТП(Кэш, ПутьККаталогу) Экспорт
	ТекстДок = Новый ТекстовыйДокумент; 
	ТекстДок.ДобавитьСтроку("ПараметрыСистемы");
	сбисЗаписатьСтруктуруВТекстовыйДокумент(Кэш.ПараметрыСистемы, ТекстДок, "   ", Новый Массив); 
	ТекстДок.ДобавитьСтроку("Настройки ВО");   
    Исключения = Новый Массив();
	Исключения.Добавить("ИдентификаторСессии"); 
	Исключения.Добавить("Пароль");
	сбисЗаписатьСтруктуруВТекстовыйДокумент(Кэш.Парам, ТекстДок, "   ", Исключения);   
	ТекстДок.ДобавитьСтроку("   ФормаРаботыСНоменклатурой: " + Кэш.ФормаРаботыСНоменклатурой);           
	ТекстДок.ДобавитьСтроку("   ФормаРаботыСоСтатусами: " + Кэш.ФормаРаботыСоСтатусами); 
	ТекстДок.ДобавитьСтроку("Текущий раздел");
	сбисЗаписатьСтруктуруВТекстовыйДокумент(Кэш.Текущий, ТекстДок, "   ", Новый Массив);
	ТекстДок.Записать(ПутьККаталогу + "ПараметрыСистемы.txt");
	ТекстДок = СбисСформироватьИнформациюПоКонстантам(); 
	ТекстДок.Записать(ПутьККаталогу + "Константы.txt");
	
	ОписаниеЗавершения = Кэш.ОбщиеФункции.СбисОписаниеОповещения(Кэш, "ДействияСНастройками_ЗавершениеВызоваКоманды", Кэш.ФормаНастроекОбщее, Новый Структура("Кэш, Отказ, ОбновитьСоставНастроек, Тип", Кэш, Ложь, Ложь, "СборТехИнформации"));
	Кэш.ФормаНастроек.СбисПолучитьНастройкиДляТП(Новый Структура("Кэш, ОписаниеОповещенияОЗавершении, КаталогНаКлиенте, ВариантОбработки, КаталогНаСервере, Распаковать", Кэш, ОписаниеЗавершения, ПутьККаталогу, 0, Кэш.Парам.ИдентификаторНастроек, Истина));
		
КонецФункции

//Функция сохраняет информацию по константам
&НаСервереБезКонтекста
Функция СбисСформироватьИнформациюПоКонстантам() Экспорт
	ТекстДок = Новый ТекстовыйДокумент; 
	Для Каждого ОчереднаяКонстанта Из Константы Цикл
		ИмяКонст = ОчереднаяКонстанта.СоздатьМенеджерЗначения().Метаданные().Имя;
		ЗначениеКонст = ОчереднаяКонстанта.Получить();
		ТекстДок.ДобавитьСтроку(ИмяКонст+": "+ЗначениеКонст);
	КонецЦикла;  
	Возврат ТекстДок;
КонецФункции

&НаКлиенте
Функция СбисСформироватьИнформациюПоДокументам1С(Кэш, ПутьККаталогу, Разделитель, Документы1С) Экспорт
	СтруктурыДокументов1С = сбисПолучитьСтруктурыДокументов1С(Документы1С, Кэш.Ини.Конфигурация); 
	СоздатьКаталог(ПутьККаталогу+"Документы1С"+Разделитель);
	Для Каждого Элем Из СтруктурыДокументов1С Цикл
		КаталогДок = ПутьККаталогу+"Документы1С"+Разделитель+Элем.Ключ+Разделитель;
		СоздатьКаталог(КаталогДок);
		СоздатьКаталог(КаталогДок+"Подобъекты"+Разделитель);
		Для Каждого Док Из Элем.Значение.Документы Цикл
			Док.Значение.Записать(КаталогДок + МестныйКэш.ОбщиеФункции.СбисЗаменитьНедопустимыеСимволыДляИмениФайла(Док.Представление)+".txt");
		КонецЦикла; 
		Для Каждого Подобъект Из Элем.Значение.Подобъекты Цикл
			Подобъект.Значение.Записать(КаталогДок+"Подобъекты" + Разделитель + МестныйКэш.ОбщиеФункции.СбисЗаменитьНедопустимыеСимволыДляИмениФайла(Подобъект.Представление)+".txt");				
		КонецЦикла;
	КонецЦикла;	
КонецФункции

Функция сбисПолучитьСтруктурыДокументов1С(Документы1С, ИниКонфигурация) 
	РезИтог = Новый Соответствие();
	РезПодобъекты = Новый СписокЗначений();
	СписокТиповСправочников = сбисСписокТиповСправочников();
	ИмяРегистраСвойствОбъектов = ИмяРегистраСвойствОбъектов(ИниКонфигурация);
	Для Каждого Док1С Из Документы1С Цикл  
		Рез = Новый Структура("Документы,Подобъекты", Новый СписокЗначений(), Новый СписокЗначений());
		сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Док1С.Значение, "Документ."+Док1С.Значение.Метаданные().Имя, 1, СписокТиповСправочников); 
		Попытка
			сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Док1С.Значение, "РегистрСведений."+ИмяРегистраСвойствОбъектов, 2, СписокТиповСправочников, "Объект");
		Исключение
			
		КонецПопытки;
		РезИтог.Вставить(СокрЛП(СтрЗаменить(Строка(Док1С.Значение),":", "_")), Рез);
	КонецЦикла;
 
	Возврат РезИтог;
КонецФункции

Функция сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Объект1С, ИмяОбъектаДляЗапроса, УровеньВложенности, СписокТиповСправочников, ИмяПоляУсловия = "Ссылка")
	ТекстДок = Новый ТекстовыйДокумент;
	Запрос = Новый Запрос ("Выбрать * Из "+ИмяОбъектаДляЗапроса+" ГДЕ "+ИмяПоляУсловия+" = &Док");
	Запрос.УстановитьПараметр("Док", Объект1С);
	Таб = Запрос.Выполнить().Выгрузить();
	Для Каждого Док Из Таб Цикл 
		Для Каждого Колонка Из Таб.Колонки Цикл
			Если ТипЗнч(Док[Колонка.Имя]) = Тип("ТаблицаЗначений") Тогда
				ТекстДок.ДобавитьСтроку(Строка(Колонка.Имя)+": ");
				сч = 0;
				Для Каждого Стр Из Док[Колонка.Имя] Цикл 
					ТекстДок.ДобавитьСтроку("   "+Строка(сч));
					Для Каждого поле Из Док[Колонка.Имя].Колонки Цикл
						ТекстДок.ДобавитьСтроку("      "+Строка(поле.Имя)+": "+Строка(Стр[поле.Имя]));
						Если поле.Имя <> "Ссылка" и УровеньВложенности < 2 и СписокТиповСправочников.НайтиПоЗначению(ТипЗнч(Стр[поле.Имя])) <> Неопределено  Тогда
							Попытка
								Если НЕ Стр[поле.Имя].Пустая() Тогда
									сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Стр[поле.Имя], "Справочник."+Стр[поле.Имя].Метаданные().Имя, УровеньВложенности+1, СписокТиповСправочников);
								КонецЕсли;
							Исключение
								
							КонецПопытки;						
						КонецЕсли;
					КонецЦикла; 
					сч = сч + 1;
				КонецЦикла;
			Иначе
				Если Колонка.Имя <> "Ссылка" и УровеньВложенности < 2 и СписокТиповСправочников.НайтиПоЗначению(ТипЗнч(Док[Колонка.Имя])) <> Неопределено  Тогда
					Попытка
						Если НЕ Док[Колонка.Имя].Пустая() Тогда
							ИмяСправочника = Док[Колонка.Имя].Метаданные().Имя;
							сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Док[Колонка.Имя], "Справочник."+ИмяСправочника, УровеньВложенности+1, СписокТиповСправочников);
							Если Метаданные.РегистрыСведений.Найти("КонтактнаяИнформация") <> Неопределено и (ИмяСправочника = "Организации" или ИмяСправочника = "Контрагенты") Тогда
								сбисЗаписатьДанныеОбъекта1СвТекстовыйДокумент(Рез, Док[Колонка.Имя], "РегистрСведений.КонтактнаяИнформация", УровеньВложенности+1, СписокТиповСправочников, "Объект");		
							КонецЕсли;
						КонецЕсли;
					Исключение
						
					КонецПопытки;						
				КонецЕсли;
				ТекстДок.ДобавитьСтроку(Строка(Колонка.Имя)+": "+Строка(Док[Колонка.Имя]));
			КонецЕсли;
		КонецЦикла;
		ТекстДок.ДобавитьСтроку("");
	КонецЦикла; 
	Если УровеньВложенности = 1 Тогда 
		Рез.Документы.Добавить(ТекстДок,СтрЗаменить(ИмяОбъектаДляЗапроса,".","_")+"_"+Строка(Объект1С));	
	Иначе
		Рез.Подобъекты.Добавить(ТекстДок,СтрЗаменить(ИмяОбъектаДляЗапроса,".","_")+"_"+Строка(Объект1С));	
	КонецЕсли;
КонецФункции 

Функция сбисСписокТиповСправочников()
	// Функция возвращает список типов переменных, которые можно вернуть с сервера на клиент (нужна для управляемых приложений)	
	СписокТиповСправочников = Новый СписокЗначений;
	Для Каждого Справочник Из Метаданные.Справочники Цикл
		СписокТиповСправочников.Добавить(Тип("СправочникСсылка."+Справочник.Имя));
	КонецЦикла;
	Возврат СписокТиповСправочников;
КонецФункции

&НаКлиенте
Функция СбисСформироватьДанныеОтладкиПоПакету(Кэш, ПутьККаталогу, СоставПакета, ИмяРеквизитаВложений) Экспорт
	КаталогОтладки = Кэш.Парам.КаталогОтладки; 
	РежимОтладки = Кэш.Парам.РежимОтладки;          
			
	МодульОбъектаКлиент().ИзменитьПараметрСбис("КаталогОтладки",ПутьККаталогу);
	МодульОбъектаКлиент().ИзменитьПараметрСбис("РежимОтладки",Истина);
	Если СоставПакета.Свойство("Вложение") Тогда
	    Если Кэш.Текущий.Раздел = "3" или Кэш.Текущий.Раздел = "4" Тогда
			Для Каждого Вложение Из СоставПакета.Вложение Цикл
				Если Вложение.Свойство("СтруктураФайла") И Вложение.СтруктураФайла.Свойство("Файл") Тогда
					ШаблонXML = Кэш.ОбщиеФункции.сбисПолучитьXMLФайлаИзСтруктуры(Кэш, Вложение);
				КонецЕсли;
			КонецЦикла;
		Иначе                                 
			ВременныйСоставПакета = Новый Структура;
			сбисСкопироватьСтруктуруНаКлиенте(ВременныйСоставПакета, СоставПакета);
			Кэш.ОбщиеФункции.РазобратьСтруктуруДокументаСбис(ВременныйСоставПакета, Кэш, ИмяРеквизитаВложений);
		КонецЕсли;
	КонецЕсли;  
	МодульОбъектаКлиент().ИзменитьПараметрСбис("КаталогОтладки",КаталогОтладки);
	МодульОбъектаКлиент().ИзменитьПараметрСбис("РежимОтладки",РежимОтладки);
	
	Если ЗначениеЗаполнено(РежимОтладки) И РежимОтладки Тогда      		
		Отказ = Ложь;
		ПараметрыКопирования = Новый Структура("КаталогИсточник, КаталогПриемник", КаталогОтладки, ПутьККаталогу + "КаталогОтладки\");
		РезультатКопирования = СбисСкопироватьФайлы(Кэш, ПараметрыКопирования, Отказ);  
		Если Отказ Тогда
			Возврат РезультатКопирования;	
		КонецЕсли;
	КонецЕсли;
		
КонецФункции    

//Процедура записывает структуру в текстовый документ
&НаКлиенте
Процедура сбисЗаписатьСтруктуруВТекстовыйДокумент(СтруктураИнфо, ТекстДок, Уровень, Исключения) Экспорт
	Для Каждого Элем Из СтруктураИнфо Цикл 
		Если Исключения.Найти(Элем.Ключ)<>Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(Элем.Значение) = Тип("Структура") Тогда  
			ТекстДок.ДобавитьСтроку(Уровень+Строка(Элем.Ключ));
			сбисЗаписатьСтруктуруВТекстовыйДокумент(Элем.Значение, ТекстДок, Уровень+"   ", Исключения);
		ИначеЕсли ТипЗнч(Элем.Значение) = Тип("Массив") Тогда
			ТекстДок.ДобавитьСтроку(Уровень+Строка(Элем.Ключ));
			сч = 0;
			Для каждого стр Из Элем.Значение Цикл
				Если ТипЗнч(стр) = Тип("Структура") Тогда	
					сбисЗаписатьСтруктуруВТекстовыйДокумент(стр, ТекстДок, Уровень+"      ", Исключения);
				Иначе
					ТекстДок.ДобавитьСтроку(Уровень+"   "+Строка(сч));
				КонецЕсли;
				сч = сч+1;
			КонецЦикла 
		ИначеЕсли ТипЗнч(Элем.Значение) = Тип("СписокЗначений") Тогда
			ТекстДок.ДобавитьСтроку(Уровень+Строка(Элем.Ключ));
			сч = 0;
			Для каждого стр Из Элем.Значение Цикл
				Если ТипЗнч(стр.Значение) = Тип("Структура") Тогда
					сбисЗаписатьСтруктуруВТекстовыйДокумент(стр.Значение, ТекстДок, Уровень+"      ", Исключения); 	
				Иначе
					ТекстДок.ДобавитьСтроку(Уровень+"   "+Строка(стр.Значение));
				КонецЕсли;
				сч = сч+1;
			КонецЦикла
		Иначе
			ТекстДок.ДобавитьСтроку(Уровень+Строка(Элем.Ключ)+": "+Элем.Значение);
		КонецЕсли;
	КонецЦикла;		
КонецПроцедуры

// Функция возвращает предствление серьтификата
// Параметры:
//  Сертификат	- Структура	- серфикат.
//
//	Шаблон		- Строка	- строка, в которой заменяются подстроки вида "[ПолеСертификата]" на строковые представления
//							  полей сертификата. Если поле не заполнено или отсутствует в сертификате, то игнорируется
//							  само поле и все рядом стоящие символы до разделителя.
//							  Например, "[ФИО]., [ИНН]".
//  СокрФИО		- Булево	- если Истина, то перед подстановкой ФИО будет сокращено до фамилии с инициалами.
//							  Значение по умолчанию - Ложь.
//  ФорматДата	- Строка	- если встречается значение поля сертификата типа Дата, то используется данный формат
//                            для преобразования даты в строку.
//  Разделитель	- Строка	- символ, который указывает, какие символы не выводятся в случае отсутствия поля.
//                            В представление не выводится.
//							  Знавение по умолчанию - ".".
//
// Возвращаемое значение:
//   Строка - представление сертификата по шаблону с подстановкой полей сертификата.
//            Если параметры указаны неправильно, возвращается Неопределено.
&НаКлиенте
Функция ПолучитьПредставлениеСертификата(Сертификат, Шаблон, СокрФИО = Ложь, ФорматДаты = "ДФ=dd.MM.yyyy", Разделитель = ".") Экспорт
	Перем ЗначениеПоляСертификата;
	
	Если Не (ТипЗнч(Сертификат) = Тип("Структура")
			И ТипЗнч(Шаблон) = Тип("Строка")
			И ТипЗнч(СокрФИО) = Тип("Булево")
			И ТипЗнч(Разделитель) = Тип("Строка")
			И СтрДлина(Разделитель) = 1
			И Найти("[]", Разделитель) = 0) Тогда
		Возврат Неопределено
	КонецЕсли;
	
	МассивЧастейШаблона = РазбитьСтрокуВМассив(Шаблон, Разделитель);
	Результат = "";
	Если СокрФИО И Сертификат.Свойство("ФИО") Тогда
		Сертификат.ФИО = СокращенноеФИО(МестныйКэш, Сертификат.ФИО);
	КонецЕсли;
	
	Для Каждого ЧастьШаблона Из МассивЧастейШаблона Цикл
		ОткСкобка = Найти(ЧастьШаблона, "[");
		ЗакСкобка = Найти(ЧастьШаблона, "]");
		Пропустить = Ложь;
		Пока ОткСкобка < ЗакСкобка Цикл
			ИмяПоля = Сред(ЧастьШаблона, ОткСкобка + 1, ЗакСкобка - ОткСкобка - 1);
			Если Не (Сертификат.Свойство(ИмяПоля, ЗначениеПоляСертификата) И ЗначениеЗаполнено(ЗначениеПоляСертификата)) Тогда
				Пропустить = Истина;
				Прервать;
			КонецЕсли;
			
			Если ТипЗнч(ЗначениеПоляСертификата) = Тип("Дата") Тогда
				ЗначениеПоляСертификата = Формат(ЗначениеПоляСертификата, ФорматДаты);
			КонецЕсли;
			
			ЧастьШаблона = СтрЗаменить(ЧастьШаблона, "[" + ИмяПоля + "]", ЗначениеПоляСертификата);
			ОткСкобка = Найти(ЧастьШаблона, "[");
			ЗакСкобка = Найти(ЧастьШаблона, "]");
		КонецЦикла;
		
		Если Пропустить Тогда
			Продолжить;
		КонецЕсли;
		
		Результат = Результат + ЧастьШаблона;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

 //1189641556 
&НаКлиенте
Функция ВыбратьДанныеСертификата(Массив, ЗначениеСтруктуры, КлючСтруктуры) Экспорт	
	Результат = Неопределено;	
	Для Каждого ЭлементМассива Из Массив Цикл
		Если ЗначениеЗаполнено(Результат) Тогда Прервать; КонецЕсли;
		Если ТипЗнч(ЭлементМассива) = Тип("Структура") Тогда
			Для Каждого ЭлементСтруктуры Из ЭлементМассива Цикл
				Если ЭлементСтруктуры.Ключ = КлючСтруктуры
					И ЭлементСтруктуры.Значение = ЗначениеСтруктуры Тогда
					Результат = Массив.Найти(ЭлементМассива);
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;	
КонецФункции 

// Функция возвращает имя запрашиваемого вида объекта
//
// Параметры:
//  ТипОбъекта - тип значения объекта 
// 
// Возвращаемое значение:
//  Строка - имя вида объекта
//
&НаСервереБезКонтекста
Функция ОпределитьИмяТипаОбъекта(ТипОбъекта)
	Возврат Метаданные.НайтиПоТипу(ТипОбъекта).Имя
КонецФункции   

// Очищает текст в формате HTML от тегов и возвращает неформатированный текст. 
//
// Параметры:
//  ИсходныйТекст - Строка - текст в формате HTML.
//
// Возвращаемое значение:
//  Строка - текст, очищенный от тегов, скриптов и заголовков.
//
&НаКлиенте
Функция ИзвлечьТекстИзHTML(Знач ИсходныйТекст) Экспорт
	Результат = "";
	
	Текст = НРег(ИсходныйТекст);
	
	// отрезаем все что не body
	Позиция = Найти(Текст, "<body");
	Если Позиция > 0 Тогда
		Текст = Сред(Текст, Позиция + 5);
		ИсходныйТекст = СокрЛП(Сред(ИсходныйТекст, Позиция + 5));
		Позиция = Найти(Текст, ">");
		Если Позиция > 0 Тогда
			Текст = Сред(Текст, Позиция + 1);
			ИсходныйТекст = СокрЛП(Сред(ИсходныйТекст, Позиция + 1));
		КонецЕсли;
	КонецЕсли;
	
	Позиция = Найти(Текст, "</body>");
	Если Позиция > 0 Тогда
		Текст = Лев(Текст, Позиция - 1);
		ИсходныйТекст = СокрЛП(Лев(ИсходныйТекст, Позиция - 1));
	КонецЕсли;
	
	// вырезаем скрипты
	Позиция = Найти(Текст, "<script");
	Пока Позиция > 0 Цикл
		ПозицияЗакрывающегоТега = Найти(Текст, "</script>");
		Если ПозицияЗакрывающегоТега = 0 Тогда
			// Не найден закрывающий тег - вырезаем оставшийся текст.
			ПозицияЗакрывающегоТега = СтрДлина(Текст);
		КонецЕсли;
		Текст = Лев(Текст, Позиция - 1) + Сред(Текст, ПозицияЗакрывающегоТега + 9);
		ИсходныйТекст = СокрЛП(Лев(ИсходныйТекст, Позиция - 1) + Сред(ИсходныйТекст, ПозицияЗакрывающегоТега + 9));
		Позиция = Найти(Текст, "<script");
	КонецЦикла;
	
	// вырезаем стили
	Позиция = Найти(Текст, "<style");
	Пока Позиция > 0 Цикл
		ПозицияЗакрывающегоТега = Найти(Текст, "</style>");
		Если ПозицияЗакрывающегоТега = 0 Тогда
			// Не найден закрывающий тег - вырезаем оставшийся текст.
			ПозицияЗакрывающегоТега = СтрДлина(Текст);
		КонецЕсли;
		Текст = Лев(Текст, Позиция - 1) + Сред(Текст, ПозицияЗакрывающегоТега + 8);
		ИсходныйТекст = СокрЛП(Лев(ИсходныйТекст, Позиция - 1) + Сред(ИсходныйТекст, ПозицияЗакрывающегоТега + 8));
		Позиция = Найти(Текст, "<style");
	КонецЦикла;
	
	// вырезаем все теги	
	Позиция = Найти(Текст, "<");
	Пока Позиция > 0 Цикл
		Результат = Результат + СокрЛП(Лев(ИсходныйТекст, Позиция-1));
		Текст = Сред(Текст, Позиция + 1);
		ИсходныйТекст = СокрЛП(Сред(ИсходныйТекст, Позиция + 1));
		Позиция = Найти(Текст, ">");
		Если Позиция > 0 Тогда
			Текст = Сред(Текст, Позиция + 1);
			ИсходныйТекст = СокрЛП(Сред(ИсходныйТекст, Позиция + 1));
		КонецЕсли;
		Позиция = Найти(Текст, "<");
	КонецЦикла;
	Результат = Результат + ИсходныйТекст;
	Возврат Результат;
КонецФункции

